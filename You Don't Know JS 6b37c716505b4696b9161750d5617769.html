<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>You Don&#x27;t Know JS</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
}

.simple-table-header {
	background: rgb(247, 246, 243);
	color: black;
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="aa196f66-cbe2-434c-b5b7-cf4b6568a4e1" class="page sans"><header><h1 class="page-title">You Don&#x27;t Know JS</h1><table class="properties"><tbody><tr class="property-row property-row-select"><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesSelect"><path d="M7,13 C10.31348,13 13,10.31371 13,7 C13,3.68629 10.31348,1 7,1 C3.68652,1 1,3.68629 1,7 C1,10.31371 3.68652,13 7,13 Z M3.75098,5.32278 C3.64893,5.19142 3.74268,5 3.90869,5 L10.09131,5 C10.25732,5 10.35107,5.19142 10.24902,5.32278 L7.15771,9.29703 C7.07764,9.39998 6.92236,9.39998 6.84229,9.29703 L3.75098,5.32278 Z"></path></svg></span>Status</th><td><span class="selected-value select-value-color-red">Reading</span></td></tr><tr class="property-row property-row-multi_select"><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesMultipleSelect"><path d="M4,3 C4,2.447715 4.447715,2 5,2 L12,2 C12.5523,2 13,2.447716 13,3 C13,3.55228 12.5523,4 12,4 L5,4 C4.447715,4 4,3.55228 4,3 Z M4,7 C4,6.447715 4.447715,6 5,6 L12,6 C12.5523,6 13,6.447716 13,7 C13,7.55228 12.5523,8 12,8 L5,8 C4.447715,8 4,7.55228 4,7 Z M4,11 C4,10.447715 4.447715,10 5,10 L12,10 C12.5523,10 13,10.447716 13,11 C13,11.55228 12.5523,12 12,12 L5,12 C4.447715,12 4,11.55228 4,11 Z M2,4 C1.44771525,4 1,3.55228475 1,3 C1,2.44771525 1.44771525,2 2,2 C2.55228475,2 3,2.44771525 3,3 C3,3.55228475 2.55228475,4 2,4 Z M2,8 C1.44771525,8 1,7.55228475 1,7 C1,6.44771525 1.44771525,6 2,6 C2.55228475,6 3,6.44771525 3,7 C3,7.55228475 2.55228475,8 2,8 Z M2,12 C1.44771525,12 1,11.5522847 1,11 C1,10.4477153 1.44771525,10 2,10 C2.55228475,10 3,10.4477153 3,11 C3,11.5522847 2.55228475,12 2,12 Z"></path></svg></span>Author</th><td><span class="selected-value select-value-color-purple">Kyle Simpson</span></td></tr><tr class="property-row property-row-url"><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesUrl"><path d="M3.73333,3.86667 L7.46667,3.86667 C8.49613,3.86667 9.33333,4.70387 9.33333,5.73333 C9.33333,6.7628 8.49613,7.6 7.46667,7.6 L6.53333,7.6 C6.01813,7.6 5.6,8.0186 5.6,8.53333 C5.6,9.04807 6.01813,9.46667 6.53333,9.46667 L7.46667,9.46667 C9.5284,9.46667 11.2,7.79507 11.2,5.73333 C11.2,3.6716 9.5284,2 7.46667,2 L3.73333,2 C1.6716,2 0,3.6716 0,5.73333 C0,7.124 0.762067,8.33453 1.88953,8.97713 C1.87553,8.83107 1.86667,8.6836 1.86667,8.53333 C1.86667,7.92013 1.98753,7.33447 2.2036,6.7978 C1.99267,6.4954 1.86667,6.12953 1.86667,5.73333 C1.86667,4.70387 2.70387,3.86667 3.73333,3.86667 Z M12.1095,5.28907 C12.1231,5.4356 12.1333,5.58307 12.1333,5.73333 C12.1333,6.34607 12.0101,6.9294 11.7931,7.46513 C12.0059,7.768 12.1333,8.13573 12.1333,8.53333 C12.1333,9.5628 11.2961,10.4 10.2667,10.4 L6.53333,10.4 C5.50387,10.4 4.66667,9.5628 4.66667,8.53333 C4.66667,7.50387 5.50387,6.66667 6.53333,6.66667 L7.46667,6.66667 C7.98187,6.66667 8.4,6.24807 8.4,5.73333 C8.4,5.2186 7.98187,4.8 7.46667,4.8 L6.53333,4.8 C4.4716,4.8 2.8,6.4716 2.8,8.53333 C2.8,10.59507 4.4716,12.2667 6.53333,12.2667 L10.2667,12.2667 C12.3284,12.2667 14,10.59507 14,8.53333 C14,7.14267 13.2375,5.93167 12.1095,5.28907 Z"></path></svg></span>Link</th><td><a href="[https://github.com/getify/You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS)" class="url-value">[https://github.com/getify/You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS)</a></td></tr><tr class="property-row property-row-text"><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesText"><path d="M7,4.56818 C7,4.29204 6.77614,4.06818 6.5,4.06818 L0.5,4.06818 C0.223858,4.06818 0,4.29204 0,4.56818 L0,5.61364 C0,5.88978 0.223858,6.11364 0.5,6.11364 L6.5,6.11364 C6.77614,6.11364 7,5.88978 7,5.61364 L7,4.56818 Z M0.5,1 C0.223858,1 0,1.223858 0,1.5 L0,2.54545 C0,2.8216 0.223858,3.04545 0.5,3.04545 L12.5,3.04545 C12.7761,3.04545 13,2.8216 13,2.54545 L13,1.5 C13,1.223858 12.7761,1 12.5,1 L0.5,1 Z M0,8.68182 C0,8.95796 0.223858,9.18182 0.5,9.18182 L11.5,9.18182 C11.7761,9.18182 12,8.95796 12,8.68182 L12,7.63636 C12,7.36022 11.7761,7.13636 11.5,7.13636 L0.5,7.13636 C0.223858,7.13636 0,7.36022 0,7.63636 L0,8.68182 Z M0,11.75 C0,12.0261 0.223858,12.25 0.5,12.25 L9.5,12.25 C9.77614,12.25 10,12.0261 10,11.75 L10,10.70455 C10,10.4284 9.77614,10.20455 9.5,10.20455 L0.5,10.20455 C0.223858,10.20455 0,10.4284 0,10.70455 L0,11.75 Z"></path></svg></span>Summary</th><td></td></tr><tr class="property-row property-row-select"><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesSelect"><path d="M7,13 C10.31348,13 13,10.31371 13,7 C13,3.68629 10.31348,1 7,1 C3.68652,1 1,3.68629 1,7 C1,10.31371 3.68652,13 7,13 Z M3.75098,5.32278 C3.64893,5.19142 3.74268,5 3.90869,5 L10.09131,5 C10.25732,5 10.35107,5.19142 10.24902,5.32278 L7.15771,9.29703 C7.07764,9.39998 6.92236,9.39998 6.84229,9.29703 L3.75098,5.32278 Z"></path></svg></span>Score /5</th><td><span class="selected-value select-value-color-default">⭐️⭐️⭐️⭐️⭐️</span></td></tr><tr class="property-row property-row-select"><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesSelect"><path d="M7,13 C10.31348,13 13,10.31371 13,7 C13,3.68629 10.31348,1 7,1 C3.68652,1 1,3.68629 1,7 C1,10.31371 3.68652,13 7,13 Z M3.75098,5.32278 C3.64893,5.19142 3.74268,5 3.90869,5 L10.09131,5 C10.25732,5 10.35107,5.19142 10.24902,5.32278 L7.15771,9.29703 C7.07764,9.39998 6.92236,9.39998 6.84229,9.29703 L3.75098,5.32278 Z"></path></svg></span>Type</th><td><span class="selected-value select-value-color-green">E-Book</span></td></tr></tbody></table></header><div class="page-body"><nav id="8a7f716e-6b4b-41d4-b4f6-b429d7a3d844" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#13415839-0a17-4080-8bce-9e80a7b8a5b2">Chapter 1.1: What Is JavaScript?</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#6acce43c-4d15-4c59-955a-4979d3809d13">Chapter 1.2: Surveying JS</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b7391089-a81c-45d2-99c3-79cbc69b01a7"><strong>Hoisting of let</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#463cd3ee-703d-4fd6-8e8e-d2fc18ee979c">Functions</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#5d96dcbc-481b-4f83-8844-3ee722cd7e29">Comparisons</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#998812af-119f-4144-8527-fd4bcf94e1eb">Coercive(forced) Comparisons ==, &lt;, &gt; </a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d5db653a-5feb-4840-8f6e-8d525a391b93">How We Organize in JS</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#98943d3b-1c4f-42d1-b7ef-c929e4d3eda8">Classes</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#ab05978b-9cb5-492b-a1c7-536cc1e913e1">Class Inheritance</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#8034d564-c5c3-43fb-b404-439d0ff002f4">Modules</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#257ec979-396f-4cfb-bee5-08eabd0b84a0">Classic Modules</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#05e036fe-605e-4377-bd1d-920d0787a16e">ES Modules (ESM)</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#ecb1ed94-3614-46a3-a655-8af71cbfee8d">Chapter 1.3: Digging to the Roots of JS</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#72a2cc12-4b73-4bb9-989b-943195356077">Iteration</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a1bdc2d8-ff7d-4e3f-a01f-3f068b4d4e83">Consuming Iterators</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b42a2f6e-8249-4450-a5db-f5a2ab9a37cc">Iterables</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#1d6d3dde-fe48-4f0a-abcb-55e03c55579a"><a href="https://www.notion.so/JavaScript-2f6f34c29b6e4a959192e669ecef84a8">Closure </a></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#72c055f5-4f51-435d-8942-6470789d242b"><mark class="highlight-red_background">this </mark>Keyword</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f7f205fb-3dda-44f3-b93c-e346089f0ded">This and Prototypes</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e318fa27-d072-4c3b-a95f-6235f5105df4">Prototypes</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#25d5b327-2cdd-4007-a588-364126a9b711"><strong>Object Linkage</strong></a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#dce0c1b0-dbfa-4f2a-b858-f3e6096af4b6">Chapter 1.4: The Bigger Picture</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#acc37eb4-ce04-4c7d-a125-65eea615342a">Pillar 1: Scope and Closure</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#abc4f401-672d-4fb2-98ca-8118a9426510">Pillar 2: Prototypes</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#116f292e-a95e-4c48-890e-3d7b764253c6">Pillar 3: Types and Coercion</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#84abd800-25d5-4ad6-bd7a-79686fe0c580">Chapter 1.Appendix A Exploring Further</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#427bda99-cacc-446d-8903-8e0244016e7f">Chapter 2 Scope and Closures</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#a8e64a7d-dd7f-48d2-bac4-f7e964bb5e74">Chapter 2.1 What&#x27;s the scope</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#193124cb-e13d-4c9d-9efa-9e7ebf97c5b5">Compiler Speak</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#cebdb350-c7c0-46dd-a354-efb9d1899bd3">Targets/ target references</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#4ad71bf9-cf67-4719-a666-9fc96f5c50be"><strong>Sources/ source references</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a8d8863e-3f24-44e3-81af-549bf92dbcec">Cheating: Runtime Scope Modifications</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#4f06bac7-7a42-459a-99e6-2526158d4f93">Ch2.2 Illustrating Lexical Scope</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#11b2d256-9ac2-4375-be60-9d5987849519"><strong>Nested Scope</strong></a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#69c03f5b-e68d-4c71-8d48-a7b06dbaa873"><strong>Lookup Failures</strong></a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#02737d8a-1c79-4abc-b567-01e21b25ba93"><strong>Undefined Mess</strong></a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#05e1e62d-80b2-4c78-91d2-05b2d5df87ee">Chapter 2.3 The Scope Chain</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b3f1f63a-0efe-4a45-adb7-76038914d71b">&quot;Lookup&quot; Is (Mostly) Conceptual</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#bbb14abf-8b1c-4e59-bd67-e403ef887d91">Shadowing</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#035254db-41d2-4c03-aa70-aad44aadf761">Global Unshadowing Trick - not a good practice </a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a0f0fb97-c239-4c6b-b5a6-7c12de255160">Copying Is Not Accessing</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#5ee1f1e5-2949-47fb-8c14-32706f86ca15">Illegal Shadowing</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#6fb22866-eb9e-4ab4-9070-1b4951addfa3">Arrow functions</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#20086e8c-8f31-47d3-8aaf-275b8b498ef0">Chapter 2.4 Around the Global Scope</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#11ac35fd-0de5-4929-bdeb-6eeb87aa9cce">Why Global Scope?</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#fdbf98e1-f82a-41c0-95f5-7d23a2ecbeda">Where Exactly is this Global Scope?</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#8aae39f4-5da2-4e18-9f69-c84dbcf5c4b8">Browser &quot;Window&quot;</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2c7588e6-a9ce-4d49-afe4-db89a088c4ce">Globals Shadowing Globals</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#1c3e87f8-bf35-4ba0-9a64-8e1334a79b7e">DOM Globals</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a2f2b392-887e-4dda-8cf5-f31dc2362583">What&#x27;s in a (Window) Name?</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#bfcebdcb-5c9b-4df9-91c4-9f6a014ee8cd">Web Workers</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#ec35cad5-2885-4b62-9757-97816e880fd4">ES Modules(ESM)</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#6f2c832d-3cba-43cc-912a-7e1b39bf4666">Node</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#6c7bb46b-86df-40b9-b5ba-d7680e931d26">Global This</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#f3806081-7f23-4fd6-ad99-a5ee1ca1c309">Chapter 2.5: The (Not So) Secret Lifecycle of Variables</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#8c1f3778-cc17-48f6-9472-4a09151b04e8">When Can I Use a Variable?</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#410518c9-f71e-45ab-aa2d-6201029539b9">Hoisting: Declaration vs. Expression</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2ec8d1b8-de2a-4117-9f11-56735adcb6b2">Variable Hoisting</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#85583392-0b29-4126-948a-c90d7469cd9d">Re-declaration</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#77e11aaf-672c-484c-adaf-47a862a3e325">Constants</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#780101eb-351e-41a7-9639-d333f5c93df9">Loops</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e75d5e51-650a-434b-87b1-ac84b2725dce">Uninitialized Variables (aka, TDZ)</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#bf801265-8d1c-405a-b000-4507e7b35b62">Chapter 2.6: Limiting Scope Exposure</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#53757caa-7997-46a8-9412-1a21a717ed9b">Least Exposure - POLE/POLP</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#c883975a-cc4a-431b-a159-8b98e0dcf8af">Hiding in Plain (Function) Scope</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#974568c9-46b6-45f5-8d45-5edd51755c9e">Invoking Function Expressions Immediately</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#388bf0e5-104c-442c-bbcd-d538ff469013"><strong>Function Boundaries</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#453bae73-9cff-418b-8c01-abc57d581314">Scoping with Blocks</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b0a5e304-7ee9-437c-b5a3-2f1112ed1315"><code>var</code> and <code>let</code></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a5856b65-99b9-46ff-b614-d3683dd7c2d7">Function Declarations in Blocks (FiB)</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#ccbae0fb-3364-4ab5-811c-b732158e6676">Chapter 2.7: Using Closures</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#4342ae22-7d43-4917-9014-40e374257986">See the Closure</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e5f26de0-cb11-4bba-aa5e-293c477c66db">Pointed Closure</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#1b32866e-faf7-428d-9c04-c9d4844b8b70">Adding Up Closures</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#c5422953-e76f-4110-b153-85c6e3a13591">Live Link, Not a Snapshot</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#952b9284-824a-4525-bb31-3ebce1aa93f8">Common Closures: Ajax and Events</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#8a878bc1-7a6f-49c6-aef7-b1f7407f2dd2">What If I Can&#x27;t See It?</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f160d32b-e53e-41f0-97f0-2f0733e8ff8c">Observable Definition</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2688fcef-3b98-498d-8f0e-8e56c114f57e">The Closure Lifecycle and Garbage Collection (GC)</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#bbcfcc61-dcc4-4bef-8c7f-729abd3b8e98">Per Scope and JS engines optimizes it to per variable</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a2afa750-cb78-4ddd-8d5d-9d7d7bffa833">An Alternative Perspective - better </a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d2677409-ef35-4197-8c25-e64c33d48237">Why Closure?</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#4eadf6dc-e871-4df7-b9b1-6fb079068fb1">Summary - Close to Closure</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#c9a6c72d-7691-45d5-8cde-1687307496e4">Chapter 2.8: The Module Pattern</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e107cd42-5b3c-4a33-b131-f7db4cc36e77">Encapsulation and Least Exposure (POLE)</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#5cb285b6-ff23-42f4-ad1b-298c73459802">What Is a Module?</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2e31a6f1-9341-4660-a1ca-749d38a4f14b"><strong>Namespaces (Stateless Grouping)</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f8205f2b-2990-4712-a49d-a2b40dcd27b4"><strong>Data Structures (Stateful Grouping)</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#eec89a40-6e7b-4dbc-baa2-a426db398c7f"><strong>Modules (Stateful Access Control)</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#5c1e9ab9-7058-4dfd-b4eb-aa0357fb7c14"><strong>Module Factory (Multiple Instances)</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f2283a96-ca34-47cb-b469-8e892fe6d71f"><strong>Classic Module Definition</strong></a></div></nav><p id="73912a00-adc3-45a9-b7ab-436992081807" class="">
</p><p id="0145da6d-1c21-4239-b9c4-d21dde43b49f" class="">
</p><h1 id="13415839-0a17-4080-8bce-9e80a7b8a5b2" class="block-color-brown_background">Chapter 1.1: What Is JavaScript?</h1><p id="d2270221-5ebb-4bd2-a85e-b80aa7bf1657" class="">web-based JS environment vs JS specification</p><p id="d920a7ce-9050-4d17-b467-7a2f410381db" class="">Depends on how you look at things. The <code>alert(..)</code> function shown here is not included in the JS specification, but it <em>is</em> in all web JS environments. Yet, you won&#x27;t find it in Appendix B, so what gives?</p><p id="099acc94-ab10-4a64-8e89-a042b9689781" class="">Various JS environments (like browser JS engines, Node.js, etc.) add APIs into the global scope of your JS programs that give you environment-specific capabilities, like being able to pop an alert-style box in the user&#x27;s browser.</p><p id="02613de2-98de-43dd-94a5-a5b75ca1f8ea" class="">REPL: read evaluate print loop = developer tool<div class="indented"><p id="45cc11ad-9847-4207-b909-634d4f0c8cae" class="">i.e. python &gt;&gt;   or F12 click on console</p></div></p><p id="f264afa0-362e-45f9-a6cf-74f9c81b0cd3" class="">The developer console is not trying to pretend to be a JS compiler that handles your entered code exactly the same way the JS engine handles a .js file. It&#x27;s trying to make it easy for you to quickly enter a few lines of code and see the results immediately. These are entirely different use cases, and as such, it&#x27;s unreasonable to expect one tool to handle both equally.</p><p id="7d9c2d93-055b-42cf-93d6-ffdda489e0b9" class="">
</p><p id="d2769a7e-3f35-4e65-a1d8-738fa127385f" class="">Typical paradigm-level code categories include procedural, object-oriented (OO/classes), and functional (FP):</p><ul id="a1001739-85b1-471a-a499-d2a5e292226e" class="bulleted-list"><li style="list-style-type:disc">Procedural style (assembly) organizes code in a top-down, linear progression through a pre-determined set of operations, usually collected together in related units called procedures.</li></ul><ul id="34b9dbc3-9d83-4aa1-abac-07d811703659" class="bulleted-list"><li style="list-style-type:disc">OO style organizes code by collecting logic and data together into units called classes.</li></ul><ul id="3399a452-b38c-4394-82e3-af3429d22870" class="bulleted-list"><li style="list-style-type:disc">FP style organizes code into functions (pure computations as opposed to procedures), and the adaptations of those functions as values.</li></ul><p id="80e38ce6-b6de-462b-b511-5524df3c145d" class="">Paradigms are neither right nor wrong. They&#x27;re orientations that guide and mold how programmers approach problems and solutions, how they structure and maintain their code.</p><p id="09945a12-0890-4c5c-a651-ce27e04346bd" class="">
</p><p id="24340dd8-120d-40b8-bdd6-6e5edcbbefdc" class="">JavaScript is most definitely a multi-paradigm language. You can write procedural, class-oriented, or FP-style code, and you can make those decisions on a line-by-line basis instead of being forced into an all-or-nothing choice.</p><p id="9dbc1241-af1f-49a6-802a-17bb515d9b0a" class="">
</p><p id="1ed513cd-71e0-436a-88e4-c9bc3c955fb1" class="">backwards compatibility: The idea is that JS developers can write code with confidence that their code won&#x27;t stop working unpredictably because a browser update is released.</p><p id="2c6be007-dd85-4afb-8ea5-2eae1d21f667" class="">JS is not forward-compatible</p><p id="29125439-127a-46a3-a18e-ac9820008bad" class="">major.minor.patch</p><p id="587f17c1-3028-4a26-a141-689c01879660" class="">1.2.1 ^ software version meaning</p><p id="c2a1f5ce-42f0-4677-9a5e-9b4505a680cc" class="">HTML and CSS, by contrast, are forwards-compatible but not backwards-compatible. If you dug up some HTML or CSS written back in 1995, it&#x27;s entirely possible it would not work today. But, if you use a new feature from 2019 in a browser from 2010, the page isn&#x27;t &quot;broken&quot; -- the unrecognized CSS/HTML is skipped over, while the rest of the CSS/HTML would be processed accordingly.</p><p id="8e523187-6e0f-47f2-8832-6b26f7c4c1c0" class="">
</p><p id="12a00016-7de1-42cc-bc36-a3023ddc3d34" class="">backward/forward compatibility:</p><figure id="6b37c716-505b-4696-b916-1750d5617769" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/9EA60C4F-04A4-45A5-AB6E-6E03A525ED62.jpeg"><img style="width:3582px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/9EA60C4F-04A4-45A5-AB6E-6E03A525ED62.jpeg"/></a></figure><p id="f8c80ac3-fac3-4db7-a89f-fe5e4ad2b1d0" class="">Transpiling is a contrived and community-invented term to describe using a tool to convert the source code of a program from one form to another</p><figure id="dc2e13a5-4719-49bf-bee7-f8754c832e9e" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled.png"><img style="width:407px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled.png"/></a></figure><p id="16b72466-3d92-4551-a102-4ec56ceb4e61" class="">Developers should focus on writing the clean, new syntax forms, and let the tools take care of producing a forwards-compatible version of that code that is suitable to deploy and run on the oldest-supported JS engine environments.</p><p id="4566c830-76da-4ab2-9df3-582508892056" class="">Transpiling: new syntax</p><p id="91aa9800-ade4-4385-9412-641708bbc66e" class="">polyfill: new api method</p><p id="eb74312b-6344-4a80-a160-cdc437fbf65d" class="">
</p><figure id="955ad3ef-b9fc-4568-b97b-c07d51daa739" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%201.png"><img style="width:610px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%201.png"/></a></figure><p id="951d3a09-ee3a-4165-b50e-1e802a126c14" class="">Transpilation and polyfilling are two highly effective techniques for addressing that gap between code that uses the latest stable features in the language and the old environments a site or application needs to still support. Since JS isn&#x27;t going to stop improving, the gap will never go away. Both techniques should be embraced as a standard part of every JS project&#x27;s production chain going forward.</p><p id="025a49e9-20e6-4809-9608-7d4328d49a15" class="">
</p><p id="f2c4fc26-540f-4bbd-80c0-e233acb276b7" class="">runtime = runtime environement</p><p id="b94168d9-2f8d-4d19-94e1-22496921998c" class="">static vs runtime error <div class="indented"><p id="b5d5d729-9401-4493-a4e0-e8da841ca03e" class="">static error: compile error</p><p id="515f5007-0ea7-471d-8693-2f4a130c4f23" class="">runtime error(lockups): error encountered while the program is running</p><p id="a5516ba8-0e13-4e53-9b8f-39585d79861d" class="">&quot;I have a runtime error&quot;, &quot;what&#x27;s your runtime(runtime environment)?&quot; &quot;node2.6&quot;</p></div></p><p id="14d56a65-b0c8-46a3-9a9c-e4768c84a8bb" class="">nodeJS is a runtime</p><p id="790f681b-d823-4d8b-9ada-7e3dd4430229" class="">dynamic types(python, JS): type of a variable can be changed </p><p id="21c908a6-90bb-40ec-9a5e-58ed28228811" class="">static types(C++):  a variable name can&#x27;t become a different type</p><p id="54510f88-730e-4da1-97fe-8c54517523cc" class="">
</p><p id="d8143205-1983-422f-a26b-79ee4d588fc7" class="">Historically, scripted or interpreted languages were executed in generally a top-down and line-by-line fashion; there&#x27;s typically not an initial pass through the program to process it before execution begins (see Figure 1).</p><p id="20ecff8c-858d-4f63-861c-b107689de24f" class="">
</p><figure id="1c6710b6-c3cb-4a84-be5d-fa6d735ea3c9" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%202.png"><img style="width:677px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%202.png"/></a></figure><p id="44a8ac4a-76df-4310-8e94-c4c47585d87a" class="">
</p><figure id="07dc613e-2634-4a44-b3c8-81808a23ed0f" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%203.png"><img style="width:1011px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%203.png"/></a></figure><p id="afa59182-bb72-44aa-878b-cd1ca77c88ba" class="">2nd graph is a AST(abstract syntax tree) ^</p><p id="43f4b6ed-cf43-4e1f-b4e4-940dfbb80375" class="">all compiled languages are parsed first.</p><p id="285826d4-fe80-4206-89f2-b15b43a7b046" class="">
</p><p id="5d80b09a-0b24-4c8b-8ab8-7beef6c7d68d" class="">WASM lets other languages run in the JS engine. </p><p id="54c76881-1ccd-4a4a-a43e-9feb0ba4a3e3" class="">
</p><p id="e29a6c63-13a1-4e5b-96da-b061f46e7f99" class="">WASM is a representation format more akin to Assembly (hence, its name) that can be processed by a JS engine by skipping the parsing/compilation that the JS engine normally does. The parsing/compilation of a WASM-targeted program happen ahead of time (AOT); what&#x27;s distributed is a binary-packed program ready for the JS engine to execute with very minimal processing.</p><p id="3ecaa966-fec8-411a-be8c-fdf79291ee17" class="">
</p><p id="564ce259-40a9-4d62-a7f9-6d0f0afda8c6" class="">An initial motivation for WASM was clearly the potential performance improvements. While that continues to be a focus, WASM is additionally motivated by the desire to bring more parity for non-JS languages to the web platform. For example, if a language like Go supports threaded programming, but JS (the language) does not, WASM offers the potential for such a Go program to be converted to a form the JS engine can understand, without needing a threads feature in the JS language itself.</p><p id="fa5ecfd1-2a94-46e5-8b64-388dd39d0b38" class="">
</p><p id="3ec68269-cde1-43d3-86e9-047034b54ead" class="">play fortnite(Unreal) on Chrome</p><p id="b0951b8d-c9d9-4e89-bf3a-f74e9e6f5993" class="">
</p><p id="27c0f7bd-9e20-45f8-a218-8e10c70d7c7b" class="">Why strict mode? Strict mode shouldn&#x27;t be thought of as a restriction on what you can&#x27;t do, but rather as a guide to the best way to do things so that the JS engine has the best chance of optimizing and efficiently running the code.</p><p id="2d63cfe4-c955-404f-ab78-977ca96bcd76" class="">
</p><p id="1d2cd17b-ac06-4ab7-896e-168335c6b1cd" class="">Most strict mode controls are in the form of early errors, meaning errors that aren&#x27;t strictly syntax errors but are still thrown at compile time (before the code is run). For example, strict mode disallows naming two function parameters the same, and results in an early error. Some other strict mode controls are only observable at runtime, such as how this defaults to undefined instead of the global object.</p><p id="bd13d6dc-6c2f-4ede-84e4-2a1d6f23ac4c" class="">
</p><p id="986af95c-8181-4da3-a3db-41887f09375f" class="">pragma meaning: a directive or pragma (from &quot;pragmatic&quot;) is a language construct that specifies how a compiler (or other translator) should process its input. Directives are not part of the grammar of a programming language, and may vary from compiler to compiler. They can be processed by a preprocessor to specify compiler behavior, or function as a form of in-band parameterization.</p><figure id="77341517-ceee-40e9-be42-a787250e2b8f" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%204.png"><img style="width:818px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%204.png"/></a></figure><p id="8231813c-8582-4b4b-970d-57098fb3e0f2" class="">
</p><figure id="5070d04f-9ddc-4bc3-ab25-c793f22d659b" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%205.png"><img style="width:834px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%205.png"/></a></figure><p id="20b5bee4-5060-4306-a757-f6b8bf0b1941" class="">
</p><p id="a426b3b3-fef3-4c7a-846b-9b378f99bac1" class="">schema = definition. it define what something looks like </p><p id="f53be835-e3e8-4ff6-af99-32239c797776" class="">
</p><p id="d3b6d3d5-eba4-4958-9071-971b7039b1d5" class="">JS is an implementation of the ECMAScript standard (version ES2019 as of this writing), which is guided by the TC39 committee and hosted by ECMA. It runs in browsers and other JS environments such as Node.js.</p><p id="39f52f3a-cd87-4c38-872d-aad67ddacb29" class="">JS is a multi-paradigm language, meaning the syntax and capabilities allow a developer to mix and match (and bend and reshape!) concepts from various major paradigms, such as procedural, object-oriented (OO/classes), and functional (FP).</p><p id="93c1d010-1278-48cd-af87-0230735d857e" class="">JS is a compiled language, meaning the tools (including the JS engine) process and verify a program (reporting any errors!) before it executes.</p><p id="a81b0592-b01a-4c38-ba0e-d057f39d6115" class="">
</p><h1 id="6acce43c-4d15-4c59-955a-4979d3809d13" class="block-color-gray_background">Chapter 1.2: Surveying JS</h1><p id="b6df8311-e2b5-4437-a7a5-b5e48b6d6307" class="">Each File is a Program</p><p id="2751e523-17c9-4a35-889e-32fb1afcbaf0" class="">Values come in two forms in JS: primitive and object.<div class="indented"><p id="7d942476-6ec1-4c46-a5f4-a1baeeac3094" class="">primitive: booleans(true/false), numbers(3.1415) and strings(&quot;words&quot;), null, undefined(better to use than null), symbol(behaves as  a hidden unguessable value, mostly used in low-level code suchs as frameworks and libraries)</p><figure id="bf57c20d-9d52-4c61-8a63-4b11bb9065c5" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%206.png"><img style="width:386px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%206.png"/></a></figure></div></p><p id="398fc281-4500-45a3-b372-226ffa6cfacf" class="">a literal is a notation for representing a fixed value in source code</p><figure id="14ef3d81-7992-47d3-bd9d-e01129b9035a" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%207.png"><img style="width:405px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%207.png"/></a></figure><p id="be90da43-b3ab-4b79-a348-f6255e75433f" class="">delimit means surround, separate, define. (example: I used the double-quote &quot; character to delimit (surround, separate, define) the string value.)</p><figure id="5e003f08-77ac-49cb-9a2c-e10492101e36" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%208.png"><img style="width:423px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%208.png"/></a></figure><p id="264abba1-cac4-4886-9dd6-e1a5f5b80829" class="">`-delimited string then resolves the variable expression (indicated with ${ .. }) to its current value. This is called interpolation.</p><p id="20ec8338-e19a-471d-a258-1bece6a5ebc9" class="">The better approach is to use &quot; or &#x27; (again, pick one and stick to it!) for strings unless you need interpolation; reserve ` only for strings that will include interpolated expressions.</p><p id="e841facf-25b1-4ab7-bf0b-1c45257fbd15" class="">syntax: console.log(), Math.PI</p><p id="82a50539-cda2-4507-a724-540be8e4ffb6" class="">
</p><figure id="67dee52a-c9c4-40d0-ab9a-d9fbf8cdbf02" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%209.png"><img style="width:384px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%209.png"/></a></figure><p id="a994f8f8-dc87-4be8-873c-d17fc8ade219" class="">Objects are more general: an unordered, keyed collection of any various values. In other words, you access the element by a string location name (aka &quot;key&quot; or &quot;property&quot;) rather than by its numeric position (as with arrays). For example:</p><figure id="22d7d816-81ed-4754-9e89-428539e0b629" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2010.png"><img style="width:324px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2010.png"/></a></figure><p id="95fa3670-6283-4994-8dac-45587c6c4a5b" class="">For distinguishing values, the typeof operator tells you its built-in type, if primitive, or &quot;object&quot; otherwise</p><figure id="fb33c73b-e63d-4cba-82a1-06fd11ad4e04" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2011.png"><img style="width:424px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2011.png"/></a></figure><p id="bbd1e35b-f6bd-4de5-9a1b-cbcca23d1c73" class="">The let keyword has some differences to var, with the most obvious being that let allows a more limited access to the variable than var. This is called &quot;block scoping&quot; as opposed to regular or function scoping.</p><figure id="819e30c5-bd5d-44ef-8047-90597ee4a5d8" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2012.png"><img style="width:746px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2012.png"/></a></figure><h3 id="b7391089-a81c-45d2-99c3-79cbc69b01a7" class=""><strong>Hoisting of let</strong></h3><p id="480649d0-5596-474a-9579-0f4b2a916c01" class="">Just like  <code>var</code>, <code>let</code> declarations are hoisted to the top. Unlike <code>var</code> which is initialized as <code>undefined</code>, the <code>let</code> keyword is not initialized. So if you try to use a <code>let</code> variable before declaration, you&#x27;ll get a <code>Reference Error</code>.</p><pre id="7643a373-9e36-4ebf-8466-335cc9e8f6b6" class="code"><code>var adult = true;

if (adult) {
    var myName = &quot;Kyle&quot;;
    let age = 39;
    console.log(&quot;Shhh, this is a secret!&quot;);
}

console.log(myName);
// Kyle

console.log(age);
// Error!</code></pre><p id="f3ddb4d2-2c85-4476-a91e-8ea7549a51df" class="">The attempt to access <code>age</code> outside of the <code>if</code> statement results in an error, because <code>age</code> was block-scoped to the <code>if</code>, whereas <code>myName</code> was not.</p><p id="6bc7ee36-b83b-4e48-8742-02f036467d24" class="">Block-scoping is very useful for limiting how widespread variable declarations are in our programs, which helps prevent accidental overlap of their names.</p><p id="3636d532-f62a-43b1-8cc2-65194bcfdade" class="">But <code>var</code> is still useful in that it communicates &quot;this variable will be seen by a wider scope (of the whole function)&quot;. Both declaration forms can be appropriate in any given part of a program, depending on the circumstances.</p><p id="c41b4dbc-a88d-4253-b12f-73a8eeeeeacf" class="">
</p><figure id="9a1e7040-ed99-4aa8-b568-6cbfc58bb727" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2013.png"><img style="width:743px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2013.png"/></a></figure><p id="74f01358-d9ca-4399-8685-2e712e1ed02f" class="">const objects cannot be redefined but the values can be updated </p><p id="1e777b5b-fa7b-4c09-bb5a-266c68fb63da" class="">
</p><p id="d101c3bf-d7ef-410b-b1d0-a691515e628c" class="">When you <strong>define </strong>a type of object, also known as a class, that is <strong>declaration</strong>. When you create an <strong>object </strong>from a class that is defined, that is <strong>instantiation</strong>. A <strong>variable </strong>is <strong>initialized </strong>with a value. An object is instantiated when memory is allocated for it and it&#x27;s constructor has been run.</p><figure id="5585e40f-1e0d-47b0-845a-517ba3a71c88" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2014.png"><img style="width:374px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2014.png"/></a></figure><p id="e70207ee-a06f-41f1-9f66-80ba6e590bd8" class="">
</p><ul id="2132d115-6274-4994-9615-40bd66836fcb" class="bulleted-list"><li style="list-style-type:disc"><code>var</code> declarations are globally scoped or function scoped while <code>let</code> and <code>const</code> are block scoped.</li></ul><ul id="73ac840b-8851-4362-a79d-301231e9e3f0" class="bulleted-list"><li style="list-style-type:disc"><code>var</code> variables can be updated and re-declared within its scope; <code>let</code> variables can be updated but not re-declared; <code>const</code> variables can neither be updated nor re-declared.</li></ul><ul id="28bd7200-23ed-45ff-b02b-f7fb2a3ba07f" class="bulleted-list"><li style="list-style-type:disc">They are all hoisted to the top of their scope. But while <code>var</code> variables are initialized with <code>undefined</code>, <code>let</code> and <code>const</code> variables are not initialized.</li></ul><ul id="bee894c1-89a9-4795-9cd9-ad3aa4ccd62e" class="bulleted-list"><li style="list-style-type:disc">While <code>var</code> and <code>let</code> can be declared without being initialized, <code>const</code> must be initialized during declaration.</li></ul><p id="f2f2e888-51b2-4b57-bb05-fb85163b30b5" class="">If you stick to using const only with primitive values, you avoid any confusion of re-assignment (not allowed) vs. mutation (allowed)! That&#x27;s the safest and best way to use const.</p><figure id="426027dd-54db-49e9-9d01-c2e96ad9258c" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2015.png"><img style="width:302px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2015.png"/></a></figure><figure id="ea4bce5b-99ec-4289-bdf4-e8997e274728" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2016.png"><img style="width:189px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2016.png"/></a></figure><h3 id="463cd3ee-703d-4fd6-8e8e-d2fc18ee979c" class="">Functions</h3><p id="77a6a368-9caf-4016-a11c-1de60c8f947f" class="">Functions can be either declarations or expression.</p><figure id="93d7477b-c5b9-494a-9ee4-db4c63f8feb8" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2017.png"><img style="width:349px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2017.png"/></a></figure><p id="194ccd4c-1603-4829-af4c-b5cd4443abae" class="">This function is an expression that is assigned to the variable awesomeFunction. Different from the function declaration form, <strong>a function expression is not associated with its identifier until that statement during runtime.</strong></p><p id="54decb02-49f3-40d8-80ff-a791b63268f7" class="">It&#x27;s extremely important to note that in JS, functions are values that can be assigned (as shown in this snippet) and passed around. In fact, JS functions are a special type of the object value type. Not all languages treat functions as values, but it&#x27;s essential for a language to support the functional programming pattern, as JS does.</p><pre id="9576ecc1-04af-4f70-952c-cf14cf65a57a" class="code"><code>var whatToSay = {
    greeting() {
        console.log(&quot;Hello!&quot;);
    },
    question() {
        console.log(&quot;What&#x27;s your name?&quot;);
    },
    answer() {
        console.log(&quot;My name is Kyle.&quot;);
    }
};

whatToSay.greeting();
// Hello!</code></pre><p id="e5183c0f-c7db-4ce5-bd2f-3a01159307b9" class="">In this snippet, references to three functions (<code>greeting()</code>, <code>question()</code>, and <code>answer()</code>) are included in the object held by <code>whatToSay</code>. Each function can be called by accessing the property to retrieve the function reference value. Compare this straightforward style of defining functions on an object to the more sophisticated <code>class</code> syntax discussed later in this chapter.</p><h3 id="5d96dcbc-481b-4f83-8844-3ee722cd7e29" class="">Comparisons</h3><pre id="87cb7a7e-62b5-4d38-8331-11918095be4a" class="code code-wrap"><code>=== is strict equals / triple equal: meaning checking both the value and the type

3 === 3.0;              // true
&quot;yes&quot; === &quot;yes&quot;;        // true
null === null;          // true
false === false;        // true

42 === &quot;42&quot;;            // false
&quot;hello&quot; === &quot;Hello&quot;;    // false
true === 1;             // false
0 === null;             // false
&quot;&quot; === null;            // false
null === undefined;     // false


NaN === NaN;            // false
0 === -0;               // true

&quot;alternatively use object is for -0 and NaN&quot;
Object.is(0, -0);                // false
Object.is(NaN, 0/0);              // true
Object.is(NaN, Number.NaN)        // true


</code></pre><p id="c08bd0d0-357a-45be-a066-ff34a3d9c3a9" class="">Since the lying about such comparisons can be bothersome, it&#x27;s best to avoid using === for them. For NaN comparisons, use the <strong>Number.isNaN(..)</strong> utility, which does not lie. For -0 comparison, use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is">Object.is(..)</a> utility, which also does not lie.<strong> Object.is(..)</strong> can also be used for non-lying NaN checks, if you prefer. Humorously, you could think of Object.is(..) as the &quot;quadruple-equals&quot; ====, the really-really-strict comparison!</p><pre id="de1a4508-a4ba-4a7f-adee-826d12420264" class="code"><code>&quot;JS does not define === as structural equality for object values. Instead, === uses identity equality for object values.&quot;
[ 1, 2, 3 ] === [ 1, 2, 3 ];    // false
{ a: 42 } === { a: 42 }         // false
(x =&gt; x * 2) === (x =&gt; x * 2)   // false

&quot;assignment is by reference-copy, so&quot;
&quot;y references the *same* array as x,&quot;
&quot;not another copy of it.&quot;
var x = [ 1, 2, 3 ];
var y = x;
y === x;              // true
y === [ 1, 2, 3 ];    // false
x === [ 1, 2, 3 ];    // false</code></pre><p id="16c77ce4-33a1-48c4-b455-a9d08dddaf84" class="">In this snippet, y === x is true because both variables hold a reference to the same initial array. But the === [1,2,3] comparisons both fail because y and x, respectively, are being compared to new different arrays [1,2,3]. The array structure and contents don&#x27;t matter in this comparison, only the reference identity.</p><h3 id="998812af-119f-4144-8527-fd4bcf94e1eb" class="">Coercive(forced) Comparisons ==, &lt;, &gt; </h3><pre id="f0c6f80e-f6c5-4e50-81e2-c0650210b8c7" class="code code-wrap"><code>42 == &quot;42&quot;;             // true
1 == true;              // true
0 == false;             // true
&quot;&quot; == 0;                // true


&quot;coercion is the action of a value being converted to a different type for comparisons&quot;
var arr = [ &quot;1&quot;, &quot;10&quot;, &quot;100&quot;, &quot;1000&quot; ];
for (let i = 0; i &lt; arr.length &amp;&amp; arr[i] &lt; 500; i++) {
    // will run 3 times
		// arr[i] &lt; 500 will be coercied to 1000 &lt; 500 at the 4th loop
}

&quot;When both are the same type/string. they yse alphabetical comparison&quot;
var x = &quot;10&quot;;
var y = &quot;9&quot;;

x &lt; y;      // true, watch out!

&quot;89&quot; &lt; &quot;9&quot;;     //true
&quot;99&quot; &lt; &quot;9&quot;      //false</code></pre><h2 id="d5db653a-5feb-4840-8f6e-8d525a391b93" class="">How We Organize in JS</h2><h3 id="98943d3b-1c4f-42d1-b7ef-c929e4d3eda8" class="">Classes</h3><p id="f6ab94cf-3b4a-4196-9154-f779cad44546" class="">A class in a program is a definition of a &quot;type&quot; of custom data structure that includes both data and behaviors that operate on that data. Classes define how such a data structure works, but classes are not themselves concrete values. To get a concrete value that you can use in the program, a class must be instantiated (with the <mark class="highlight-red_background">new </mark>keyword) one or more times. </p><pre id="47989818-ee85-475d-990b-e288c16af0fb" class="code code-wrap"><code>class Notebook {
...
}

var mathNotes = new Notebook();
&quot;mathNotes = new Notebook() creates an instance of the Notebook class&quot;</code></pre><h3 id="ab05978b-9cb5-492b-a1c7-536cc1e913e1" class="">Class Inheritance</h3><p id="c79993d8-58cb-49d9-aa52-988742e173c6" class="">Both <code>Book</code> and <code>BlogPost</code> use the <code>extends</code> clause to <em>extend</em> the general definition of <code>Publication</code> to include additional behavior. The <code>super(..)</code> call in each constructor delegates to the parent <code>Publication</code> class&#x27;s constructor for its initialization work, and then they do more specific things according to their respective publication type (aka, &quot;sub-class&quot; or &quot;child class&quot;).</p><figure id="d1010c7e-d230-46dd-ab42-888687c4e667" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2018.png"><img style="width:469px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2018.png"/></a></figure><p id="5672b684-441d-437e-acaa-58043b2786f2" class="">Notice that both child class instances have a <code>print()</code> method, which was an override of the <em>inherited</em> <code>print()</code> method from the parent <code>Publication</code> class. Each of those overridden child class <code>print()</code> methods call <code>super.print()</code> to invoke the inherited version of the <code>print()</code> method.</p><p id="a78e8351-99f8-4707-a333-e0857bdfb0aa" class="">Both <code>Book</code> and <code>BlogPost</code> use the <code>extends</code> clause to <em>extend</em> the general definition of <code>Publication</code> to include additional behavior. The <code>super(..)</code> call in each constructor delegates to the parent <code>Publication</code> class&#x27;s constructor for its initialization work, and then they do more specific things according to their respective publication type (aka, &quot;sub-class&quot; or &quot;child class&quot;).</p><p id="a0a9ae34-f5b2-475d-84b1-90c7524c01b4" class="">Now consider using these child classes:</p><p id="6b8200c2-277f-4d85-8b39-7173d4a2c4db" class="">The fact that both the inherited and overridden me</p><h3 id="8034d564-c5c3-43fb-b404-439d0ff002f4" class="">Modules</h3><h3 id="257ec979-396f-4cfb-bee5-08eabd0b84a0" class="">Classic Modules</h3><figure id="84dcddfb-73f6-44ad-a426-b7e163f021d2" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2019.png"><img style="width:869px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2019.png"/></a></figure><figure id="1c4ab9d2-e16b-47cf-b4a8-a281be6286c9" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2020.png"><img style="width:823px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2020.png"/></a></figure><p id="529e0aec-2cd2-4428-92d8-0fe2d56ad4fb" class="">Difference:
Notice that both child class instances have a <code>print()</code> method, which was an override of the <em>inherited</em> <code>print()</code> method from the parent <code>Publication</code> class. Each of those overridden child class <code>print()</code> methods call <code>super.print()</code> to invoke the inherited version of the <code>print()</code> method.
The fact that both the inherited and overridden me
Comparing these forms to the <code>class</code> forms, there are more similarities than differences.
The <code>class</code> form stores methods and data on an object instance, which must be accessed with the <code>this.</code> prefix. With modules, the methods and data are accessed as identifier variables in scope, without any <code>this.</code> prefix.
With <code>class</code>, the &quot;API&quot; of an instance is implicit in the class definition—also, all data and methods are public. With the module factory function, you explicitly create and return an object with any publicly exposed methods, and any data or other unreferenced methods remain private inside the factory function.</p><p id="62929421-bccb-467b-aa92-58888a851cea" class="">module: more private, class all public</p><h3 id="05e036fe-605e-4377-bd1d-920d0787a16e" class="">ES Modules (ESM)</h3><p id="eb11f373-4c5f-4d03-9878-b972e81b440e" class="">difference btw ESM &amp; classic modules</p><p id="4ba1e7a1-0f78-42a3-8360-2e5293ff2aba" class="">First, there&#x27;s no wrapping function to <em>define</em> a module. The wrapping context is a file. ESMs are always file-based; one file, one module.</p><p id="151cde1b-b142-48fb-b57c-64128748bffc" class="">Second, you don&#x27;t interact with a module&#x27;s &quot;API&quot; explicitly, but rather use the <code>export</code> keyword to add a variable or method to its public API definition. If something is defined in a module but not <code>export</code>ed, then it stays hidden (just as with <em>classic modules</em>).</p><p id="c53542e5-3182-4e3b-8c96-5c7f699bdb15" class="">Third, and maybe most noticeably different from previously discussed patterns, you don&#x27;t &quot;instantiate&quot; an ES module, you just <code>import</code> it to use its single instance. ESMs are, in effect, &quot;singletons,&quot; in that there&#x27;s only one instance ever created, at first <code>import</code> in your program, and all other <code>import</code>s just receive a reference to that same single instance. If your module needs to support multiple instantiations, you have to provide a <em>classic module-style</em> factory function on your ESM definition for that purpose.</p><p id="1012d9fb-e966-4f8d-babb-82d5f84ac266" class="">example:</p><p id="bc476fa4-8a52-48e0-9e12-3a140af7ac0f" class="">Consider the file <code>publication.js</code>:</p><pre id="5dec3e7e-3bac-4102-934d-4525a4d5fa57" class="code"><code>function printDetails(title,author,pubDate) {
    console.log(`
        Title: ${ title }
        By: ${ author }
        ${ pubDate }
    `);
}

export function create(title,author,pubDate) {
    var publicAPI = {
        print() {
            printDetails(title,author,pubDate);
        }
    };

    return publicAPI;
}</code></pre><p id="cf6b1aca-7667-40a7-a2b4-9153a4081457" class="">To import and use this module, from another ES module like <code>blogpost.js</code>:</p><p id="79df477f-bff8-47ce-af52-0da1f7a80a1a" class="">
</p><pre id="79f198be-f0b8-4355-8b11-1761dee8ddb5" class="code"><code>import { create as createPub } from &quot;publication.js&quot;;

function printDetails(pub,URL) {
    pub.print();
    console.log(URL);
}

export function create(title,author,pubDate,URL) {
    var pub = createPub(title,author,pubDate);

    var publicAPI = {
        print() {
            printDetails(pub,URL);
        }
    };

    return publicAPI;
}</code></pre><p id="0b833dbd-5a24-4b0a-b6a0-cac1d3ed4f0b" class="">And finally, to use this module, we import into another ES module like <code>main.js</code>:</p><pre id="f3a5ad3d-d1bf-4ffc-a486-e258e0232565" class="code"><code>import { create as newBlogPost } from &quot;blogpost.js&quot;;

var forAgainstLet = newBlogPost(
    &quot;For and against let&quot;,
    &quot;Kyle Simpson&quot;,
    &quot;October 27, 2014&quot;,
    &quot;https://davidwalsh.name/for-and-against-let&quot;
);

forAgainstLet.print();
// Title: For and against let
// By: Kyle Simpson
// October 27, 2014
// https://davidwalsh.name/for-and-against-letThe as newBlogPost clause in the import statement is optional; if omitted, a top-level function just named create(..) would be imported. In this case, I&#x27;m renaming it for readability&#x27;s sake; its more generic factory name of create(..) becomes more semantically descriptive of its purpose as newBlogPost(..).</code></pre><p id="73ae4728-97a5-41ba-869b-8d465b1f49b4" class="">The <mark class="highlight-red_background">as newBlogPos</mark>t clause in the import statement is optional; if omitted, a top-level function just named <mark class="highlight-red_background">create(..)</mark> would be imported.</p><h1 id="ecb1ed94-3614-46a3-a655-8af71cbfee8d" class="block-color-red_background">Chapter 1.3: Digging to the Roots of JS</h1><h3 id="72a2cc12-4b73-4bb9-989b-943195356077" class="">Iteration</h3><p id="4abb3f36-59d8-465f-be5f-1737d14fc0b3" class="">ES6 standardized a specific protocol for the iterator pattern directly in the language. The protocol defines a <code>next()</code> method whose return is an object called an <em>iterator result</em>; the object has <code>value</code> and <code>done</code> properties, where <code>done</code> is a boolean that is <code>false</code> until the iteration over the underlying data source is complete.</p><h3 id="a1bdc2d8-ff7d-4e3f-a01f-3f068b4d4e83" class="">Consuming Iterators</h3><p id="a9017b6f-e5bc-4cb3-bf4a-3a2e61866092" class=""> <code>for..of</code> loop:</p><pre id="28f64738-811b-41f0-8c3c-4ee955229982" class="code code-wrap"><code>// given an iterator of some data source:
var it = /* .. */;

// loop over its results one at a time
for (let val of it) {
    console.log(`Iterator value: ${ val }`);
}</code></pre><p id="2f735c14-c03f-47df-884c-4b52cc3bbbb9" class=""><code>...</code> operator has two symmetrical forms: <em>spread</em> and <em>rest(</em>(or <em>gather</em>)<em>).</em></p><p id="f8c69987-0913-47f4-9f79-419be62e4b64" class="">The <em>spread</em> form is an iterator-consumer. To <em>spread </em>an iterator, you have to have <em>something </em>to spread it into. There are two possibilities in JS: an array or an argument list for a function call.</p><p id="0f035b58-bef1-4b58-b0d0-c57c1e4bab87" class="">For function calls:</p><pre id="3560a1b3-c202-4e23-8c74-cbde807e6eed" class="code code-wrap"><code>myFunction(...iterableObj); // pass all elements of iterableObj as arguments to function myFunction
</code></pre><p id="6970ce83-adc9-4903-814a-7d6a2db4b9cb" class="">For array literals or strings:</p><pre id="71b39c4b-b0c8-46b0-8249-b883351322c2" class="code code-wrap"><code>[...iterableObj, &#x27;4&#x27;, &#x27;five&#x27;, 6]; // combine two arrays by inserting all elements from iterableObj</code></pre><p id="b0290c33-9a92-4be4-8f3d-ad6e7469e057" class="">For object literals (new in ECMAScript 2018):</p><pre id="9f97b552-e781-4de2-a824-996ea7ed3c59" class="code code-wrap"><code>let objClone = { ...obj }; // pass all key:value pairs from an object</code></pre><p id="12339d80-b595-4528-a9b3-b52bf586eaf1" class="">An array spread:</p><pre id="892d469d-f181-485a-93e7-7b835eee914b" class="code"><code>// spread an iterator into an array,
// with each iterated value occupying
// an array element position.
var vals = [ ...it ]; // vals is an array</code></pre><p id="c8518b65-ea13-4c9e-817d-ca0f51706891" class="">A function call spread:</p><pre id="dbe712db-c6ec-4c1d-8c3f-2fd48f90abfb" class="code"><code>// spread an iterator into a function,
// call with each iterated value
// occupying an argument position.
doSomethingUseful( ...it ); 

function sum(x, y, z) {
  return x + y + z;
}

const numbers = [1, 2, 3];

console.log(sum(...numbers));
// expected output: 6

console.log(sum.apply(null, numbers));
// expected output: 6</code></pre><p id="555de6dc-d84b-4e57-a577-eaa5115e3feb" class="">In both cases, the iterator-spread form of <code>...</code> follows the iterator-consumption protocol (the same as the <code>for..of</code> loop) to retrieve all available values from an iterator and place (aka, spread) them into the receiving context (array, argument list).</p><p id="30ac35ec-488a-44d5-bc0c-2fc9befdfff4" class="">The iterator-consumption protocol is technically defined for consuming <em>iterables</em>; an iterable is a value that can be iterated over.</p><p id="22b8cd9b-ad47-4956-b43e-974b8b7ba291" class="">The protocol automatically creates an iterator instance from an iterable, and consumes <em>just that iterator instance</em> to its completion. This means a single iterable could be consumed more than once; each time, a new iterator instance would be created and used.</p><h3 id="b42a2f6e-8249-4450-a5db-f5a2ab9a37cc" class="">Iterables</h3><p id="4cff348c-3d7d-43ed-bb1e-cae12cdc0616" class="">an iterable is a value that can be iterated over. the basic data structure/collection types in JS as iterables. This includes strings, arrays, maps, sets, and others.</p><pre id="2f8f4ddf-6c49-4841-9832-acf9668bd45f" class="code"><code>// an array is an iterable
var arr = [ 10, 20, 30 ];

for (let val of arr) {
    console.log(`Array value: ${ val }`);
}
// Array value: 10
// Array value: 20
// Array value: 30</code></pre><p id="5d867220-d4d4-4f16-a93b-b11a32338785" class="">Since arrays are iterables, we can shallow-copy an array using iterator consumption via the <code>...</code> spread operator:</p><pre id="c9a86d1d-ed18-4749-86a4-a70841c6a0c4" class="code"><code>var arrCopy = [ ...arr ];</code></pre><p id="e8f0a9bb-9222-42dd-a1d5-273f74c9358b" class="">We can also iterate the characters in a string one at a time:</p><pre id="a10ff66a-4cb3-4c11-8a05-9912aa7e166b" class="code"><code>var greeting = &quot;Hello world!&quot;;
var chars = [ ...greeting ];

chars;
// [ &quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot; &quot;,
//   &quot;w&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;, &quot;!&quot; ]</code></pre><p id="71af8d69-a23e-4b22-9685-447a59d71edf" class="">A <code>Map</code> data structure uses objects as keys, associating a value (of any type) with that object. Maps have a different default iteration than seen here, in that the iteration is not just over the map&#x27;s values but instead its <em>entries</em>. An <em>entry</em> is a tuple (2-element array) including both a key and a value.</p><p id="da48b56b-cd45-40db-95e0-ef3408776a56" class="">Consider:</p><pre id="3b32b8d7-51fe-43a5-bcf2-765c3a76f733" class="code"><code>// given two DOM elements, `btn1` and `btn2`

var buttonNames = new Map();
buttonNames.set(btn1,&quot;Button 1&quot;);
buttonNames.set(btn2,&quot;Button 2&quot;);

for (let [btn,btnName] of buttonNames) {
    btn.addEventListener(&quot;click&quot;,function onClick(){
        console.log(`Clicked ${ btnName }`);
    });
}

for (let btnName of buttonNames.values()) {
    console.log(btnName);
}
// Button 1
// Button 2</code></pre><p id="63b2ea81-b251-48a5-893f-95a05f08ea19" class="">In the <code>for..of</code> loop over the default map iteration, we use the <code>[btn,btnName]</code> syntax (called &quot;array destructuring&quot;) to break down each consumed tuple into the respective key/value pairs (<code>btn1</code> / <code>&quot;Button 1&quot;</code> and <code>btn2</code> / <code>&quot;Button 2&quot;</code>).</p><p id="476d78a3-a6a8-4bce-b35c-d8864dc0bc70" class="">Each of the built-in iterables in JS expose a default iteration, one which likely matches your intuition. But you can also choose a more specific iteration if necessary. For example, if we want to consume only the values of the above <code>buttonNames</code> map, we can call <code>values()</code> to get a values-only iterator:</p><p id="bc2d9640-5d7f-49b5-9a4f-84e9676e4066" class="">if we want the index <em>and</em> value in an array iteration, we can make an entries iterator with the <code>entries()</code> method:</p><pre id="6c6d3f5e-7207-414c-832e-b7021aff1f47" class="code"><code>var arr = [ 10, 20, 30 ];

for (let [idx,val] of arr.entries()) {
    console.log(`[${ idx }]: ${ val }`);
}
// [0]: 10
// [1]: 20
// [2]: 30</code></pre><p id="9340b182-7bb4-4fbf-8489-13b504943f41" class="">For the most part, all built-in iterables in JS have three iterator forms available: keys-only (<code>keys()</code>), values-only (<code>values()</code>), and entries (<code>entries()</code>).</p><h3 id="1d6d3dde-fe48-4f0a-abcb-55e03c55579a" class=""><a href="https://www.notion.so/JavaScript-2f6f34c29b6e4a959192e669ecef84a8">Closure </a></h3><p id="9df7d9e1-6561-4486-b0c2-00dda91e9494" class="">Closure is when a <strong>function(only function &amp; inner function) </strong>remembers and continues to access variables from outside its scope, even when the function is executed in a different scope.</p><p id="daa99049-35bd-4cd4-a783-1e57a0dbde2e" class="">These closures are not a snapshot of the variable&#x27;s value; they are a direct link and preservation of the variable itself. That means closure can actually observe (or make!) updates to these variables over time.</p><pre id="4c56265b-e54f-498e-816b-c3dfcb9fa1c1" class="code code-wrap"><code>&quot;closures update the original variable value&quot;
function counter(step = 1) {
    var count = 0;
    return function increaseCount(){
        count = count + step;
        return count;
    };
}

var incBy1 = counter(1);
var incBy3 = counter(3);

incBy1();       // 1
incBy1();       // 2

incBy3();       // 3
incBy3();       // 6
incBy3();       // 9</code></pre><p id="bf0d0b58-7f81-416f-aa36-265460e5963c" class="">Each instance of the inner <code>increaseCount()</code> function is closed over both the <code>count</code> and <code>step</code> variables from its outer <code>counter(..)</code> function&#x27;s scope. <code>step</code> remains the same over time, but <code>count</code> is updated on each invocation of that inner function. Since closure is over the variables and not just snapshots of the values, these updates are preserved.</p><pre id="1e2158b7-7d2a-44f1-aed2-8cde58c686c8" class="code"><code>&quot;async example&quot; 
&quot;The inner function onResponse(..) is closed over url&quot;
function getSomeData(url) {
    ajax(url,function onResponse(resp){
        console.log(
            `Response (from ${ url }): ${ resp }`
        );
    });
}

getSomeData(&quot;https://some.url/wherever&quot;);
// Response (from https://some.url/wherever): ...</code></pre><p id="7ee66b1e-b06e-4343-93f3-36826d49f84d" class="">The inner function <code>onResponse(..)</code> is closed over <code>url</code>, and thus preserves and remembers it until the Ajax call returns and executes <code>onResponse(..)</code>. Even though <code>getSomeData(..)</code> finishes right away, the <code>url</code> parameter variable is kept alive in the closure for as long as needed.</p><pre id="db0e062f-f6b9-405b-94b8-b7a0cdd91761" class="code"><code>for (let [idx,btn] of buttons.entries()) {
    btn.addEventListener(&quot;click&quot;,function onClick(){
       console.log(`Clicked on button (${ idx })!`);
    });
}</code></pre><p id="cdd478c2-0760-4119-8684-5665b4d3d0b7" class="">Because this loop is using <code>let</code> declarations, each iteration gets new block-scoped (aka, local) <code>idx</code> and <code>btn</code> variables; the loop also creates a new inner <code>onClick(..)</code> function each time. That inner function closes over <code>idx</code>, preserving it for as long as the click handler is set on the <code>btn</code>. So when each button is clicked, its handler can print its associated index value, because the handler remembers its respective <code>idx</code> variable.</p><p id="65008630-24bd-420b-8bef-826418be36fc" class="">Remember: this closure is not over the value (like <code>1</code> or <code>3</code>), but over the variable <code>idx</code> itself.</p><h3 id="72c055f5-4f51-435d-8942-6470789d242b" class=""><mark class="highlight-red_background">this </mark>Keyword</h3><p id="fdb8c3b6-e291-4d20-aac8-cc92d1161741" class="">when a function is defined, it is <em>attached</em> to its enclosing scope via closure. Scope is the set of rules that controls how references to variables are resolved.</p><p id="f72a3020-09f8-4598-9f9a-9e5f0a51c432" class="">But functions also have another characteristic besides their scope that influences what they can access. This characteristic is best described as an <em>execution context</em>, and it&#x27;s exposed to the function via its <code>this</code> keyword.</p><p id="d13be11d-8e5c-4bc9-bc6f-a78d9217bc0c" class="">Scope is static and contains a fixed set of variables available at the moment and location you define a function, but a function&#x27;s execution <em>context</em> is dynamic, entirely dependent on <strong>how it is called</strong> (regardless of where it is defined or even called from).</p><p id="6c02a83f-e80d-45b1-8cb2-d3a119e721cd" class=""><code>this</code> is not a fixed characteristic of a function based on the function&#x27;s definition, but rather a dynamic characteristic that&#x27;s determined each time the function is called.</p><p id="4f07a997-cc8b-40d1-8710-45247316a3ec" class="">One way to think about the <em>execution context</em> is that it&#x27;s a tangible object whose properties are made available to a function while it executes. Compare that to scope, which can also be thought of as an <em>object</em>; except, the <em>scope object</em> is hidden inside the JS engine, it&#x27;s always the same for that function, and its <em>properties</em> take the form of identifier variables available inside the function.</p><pre id="e07c84ab-c537-4d94-bb2f-6705fef9efcb" class="code"><code>function classroom(teacher) {
    return function study() {
        console.log(
            `${ teacher } says to study ${ this.topic }`
        );
    };
}
var assignment = classroom(&quot;Kyle&quot;);</code></pre><p id="107ce3de-db05-409f-9b58-8c13a5ccb08a" class="">The outer <code>classroom(..)</code> function makes no reference to a <code>this</code> keyword, so it&#x27;s just like any other function we&#x27;ve seen so far. But the inner <code>study()</code> function does reference <code>this</code>, which makes it a <code>this</code>-aware function. In other words, it&#x27;s a function that is dependent on its <em>execution context</em>.</p><p id="fe93a9d3-8ec0-4f85-9fde-ca8a4dfc6df2" class="">The inner <code>study()</code> function returned by <code>classroom(&quot;Kyle&quot;)</code> is assigned to a variable called <code>assignment</code>. So how can <code>assignment()</code> (aka <code>study()</code>) be called?</p><pre id="28d5aa81-ca40-4ee5-a4a9-d36698289afd" class="code"><code>assignment();
// Kyle says to study undefined  -- Oops :(</code></pre><p id="9ae63603-1ce0-4803-9d92-9da52a279685" class="">In this snippet, we call <code>assignment()</code> as a plain, normal function, without providing it any <em>execution context</em>.</p><p id="eee4a9e5-4832-49e2-ae0e-7383e609b2f6" class="">Since this program is not in strict mode (see Chapter 1, &quot;Strictly Speaking&quot;), context-aware functions that are called <strong>without any context specified</strong> default the context to the global object (<code>window</code> in the browser). As there is no global variable named <code>topic</code> (and thus no such property on the global object), <code>this.topic</code> resolves to <code>undefined</code>.</p><p id="ce852079-4546-479b-96e8-cdce06ac962e" class="">Now consider:</p><pre id="9b7c5616-6ad8-4d12-8ee4-863d658e4eb8" class="code"><code>var homework = {
    topic: &quot;JS&quot;,
    assignment: assignment
};

homework.assignment();
// Kyle says to study JS</code></pre><p id="04cd3b00-47b0-4a23-b669-6fe9a94d5b37" class="">A copy of the <code>assignment</code> function reference is set as a property on the <code>homework</code> object, and then it&#x27;s called as <code>homework.assignment()</code>. That means the <code>this</code> for that function call will be the <code>homework</code> object. Hence, <code>this.topic</code> resolves to <code>&quot;JS&quot;</code>.</p><p id="91c17a6e-ff68-42e2-86e6-dab06e944f5f" class="">Lastly:</p><pre id="08507d18-968e-4802-88ec-24de85d33cc7" class="code"><code>var otherHomework = {
    topic: &quot;Math&quot;
};

assignment.call(otherHomework);
// Kyle says to study Math</code></pre><p id="67e26ac7-35c8-456e-b594-a513fb362699" class=""><mark class="highlight-yellow_background">A third way to invoke a function is with the </mark><mark class="highlight-yellow_background"><code>call(..)</code></mark><mark class="highlight-yellow_background"> method, which takes an object (</mark><mark class="highlight-yellow_background"><code>otherHomework</code></mark><mark class="highlight-yellow_background"> here) to use for setting the </mark><mark class="highlight-yellow_background"><code>this</code></mark><mark class="highlight-yellow_background"> reference for the function call.</mark> The property reference <code>this.topic</code> resolves to <code>&quot;Math&quot;</code>.</p><p id="9fa38a7c-093a-4e73-ac65-7fea3db4a830" class="">The same context-aware function invoked three different ways, gives different answers each time for what object <code>this</code> will reference.</p><p id="4c9e37e8-f736-41c1-b86a-46942416c5e3" class="">The benefit of <code>this</code>-aware functions—and their dynamic context—is the ability to more flexibly re-use a single function with data from different objects. A function that closes over a scope can never reference a different scope or set of variables. But a function that has dynamic <code>this</code> context awareness can be quite helpful for certain tasks.</p><h3 id="f7f205fb-3dda-44f3-b93c-e346089f0ded" class="">This and Prototypes</h3><p id="47d072f2-6729-4c45-ac5f-dffbc06695c2" class=""> one of the main reasons <code>this</code> supports dynamic context based on how the function is called is so that method calls on objects which delegate through the prototype chain still maintain the expected <code>this</code>.</p><p id="219e24d5-fd3d-4a7d-b163-c72c7659a7d6" class="">Consider:</p><pre id="80c67a65-dfe2-4608-b949-ab778245d64f" class="code"><code>var homework = {
    study() {
        console.log(`Please study ${ this.topic }`);
    }
};

var jsHomework = Object.create(homework);
jsHomework.topic = &quot;JS&quot;;
jsHomework.study();
// Please study JS

var mathHomework = Object.create(homework);
mathHomework.topic = &quot;Math&quot;;
mathHomework.study();
// Please study Math</code></pre><p id="98b4cfbd-329e-4038-b051-5df81ca1cf12" class="">The two objects <code>jsHomework</code> and <code>mathHomework</code> each prototype link to the single <code>homework</code> object, which has the <code>study()</code> function. <code>jsHomework</code> and <code>mathHomework</code> are each given their own <code>topic</code> property (see Figure 6).</p><figure id="ec36f85f-79e5-4245-af27-3f7c61c918c0" class="image"><a href="https://github.com/getify/You-Dont-Know-JS/raw/2nd-ed/get-started/images/fig6.png"><img style="width:528px" src="https://github.com/getify/You-Dont-Know-JS/raw/2nd-ed/get-started/images/fig6.png"/></a></figure><p id="c7f75aff-30b5-4edf-914c-7245362d1e23" class=""><em>Fig. 6: Two objects linked to a common parent</em></p><p id="b4b497aa-c6dd-4afc-b562-35471279256b" class=""><code>jsHomework.study()</code> delegates to <code>homework.study()</code>, but its<mark class="highlight-red_background"> </mark><mark class="highlight-red_background"><code>this</code></mark><mark class="highlight-red_background"> (</mark><mark class="highlight-red_background"><code>this.topic</code></mark><mark class="highlight-red_background">) for that execution resolves to </mark><mark class="highlight-red_background"><code>jsHomework</code></mark><mark class="highlight-red_background"> because of how the function is called, so </mark><mark class="highlight-red_background"><code>this.topic</code></mark><mark class="highlight-red_background"> is </mark><mark class="highlight-red_background"><code>&quot;JS&quot;</code></mark>. Similarly for <code>mathHomework.study()</code> delegating to <code>homework.study()</code> but still resolving <code>this</code> to <code>mathHomework</code>, and thus <code>this.topic</code> as <code>&quot;Math&quot;</code>.</p><p id="2ec3243e-27a8-4575-a44a-2c7f5380d141" class="">The preceding code snippet would be far less useful if <code>this</code> was resolved to <code>homework</code>. Yet, in many other languages, it would seem <code>this</code> would be <code>homework</code> because the <code>study()</code> method is indeed defined on <code>homework</code>.</p><p id="7d7d5172-6abd-478b-8fb7-30023df294be" class="">Unlike many other languages, JS&#x27;s <code>this</code> being dynamic is a critical component of allowing prototype delegation, and indeed <code>class</code>, to work as expected!</p><h3 id="e318fa27-d072-4c3b-a95f-6235f5105df4" class="">Prototypes</h3><p id="a41adb73-2ec1-4d70-9b71-adaf93087fe1" class="">Where <code>this</code> is a characteristic of function execution, a prototype is a characteristic of an object, and specifically resolution of a property access.</p><p id="1727e553-9df9-4066-8158-3a3177bfc5c3" class="">Think about a prototype as a linkage between two objects; the linkage is hidden behind the scenes, though there are ways to expose and observe it. This prototype linkage occurs when an object is created; it&#x27;s linked to another object that already exists.</p><p id="91f0c6a8-5e2a-44d2-9813-1567b1f40a78" class="">A series of objects linked together via prototypes is called the &quot;prototype chain.&quot;</p><p id="879ef265-de25-4346-bc72-1f48bff48c6e" class="">The purpose of this prototype linkage (i.e., from an object B to another object A) is so that accesses against B for properties/methods that B does not have, are <em>delegated</em> to A to handle. Delegation of property/method access allows two (or more!) objects to cooperate with each other to perform a task.</p><p id="e58752a7-1dfd-4c15-8176-b358c58a763a" class="">Consider defining an object as a normal literal:</p><pre id="82499b36-1a69-47d8-b2a6-3f5b80a72ef8" class="code"><code>var homework = {
    topic: &quot;JS&quot;
};</code></pre><p id="3689881e-5ee2-4fec-be84-c92e3495582e" class="">The <code>homework</code> object only has a single property on it: <code>topic</code>. However, its default prototype linkage connects to the <code>Object.prototype</code> object, which has common built-in methods on it like <code>toString()</code> and <code>valueOf()</code>, among others.</p><p id="a38d892a-4e3c-4cd5-9c9e-543d424d7f46" class="">We can observe this prototype linkage <em>delegation</em> from <code>homework</code> to <code>Object.prototype</code>:</p><pre id="216cf40e-9549-4d4a-9c99-02c88ec2c443" class="code"><code>homework.toString();    // [object Object]
&quot;Object.prototype.toString() returns [object type], in this case, homework is an Object&quot;
&quot;therefore returns [object Object]&quot;</code></pre><p id="37763a8e-7aab-4297-8f0b-ffbeb98ce70a" class=""><code>homework.toString()</code> works even though <code>homework</code> doesn&#x27;t have a <code>toString()</code> method defined; the delegation invokes <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString"><code>Object.prototype.toString()</code></a> instead.</p><h3 id="25d5b327-2cdd-4007-a588-364126a9b711" class=""><strong>Object Linkage</strong></h3><p id="48009587-d63b-419d-9007-b3929691cf58" class="">To define an object prototype linkage, you can create the object using the <code>Object.create(..)</code> utility:</p><pre id="89693e55-a0f0-4d36-afb7-5874aea5e207" class="code"><code>var homework = {
    topic: &quot;JS&quot;
};

var otherHomework = Object.create(homework);

otherHomework.topic;   // &quot;JS&quot;</code></pre><p id="c2366651-9f4f-4d23-b690-3782cb35b321" class="">The first argument to <code>Object.create(..)</code> specifies an object to link the newly created object to, and then returns the newly created (and linked!) object.</p><p id="7cce4210-4fc4-4e69-88a9-abbf79add398" class="">how the three objects (<code>otherHomework</code>, <code>homework</code>, and <code>Object.prototype</code>) are linked in a prototype chain:</p><figure id="eb3269e4-e456-4e19-b2dd-c952934d622e" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2021.png"><img style="width:192px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2021.png"/></a></figure><p id="c5549a31-e317-440f-a04a-a5f8e29be0de" class="">Delegation through the prototype chain only applies for accesses to lookup the value in a property. If you assign to a property of an object, that will apply directly to the object regardless of where that object is prototype linked to.</p><p id="6f987cb2-aa0c-4940-805c-8e1f606e04c7" class=""><mark class="highlight-red_background">Object.create(null)</mark> creates an object that is not prototype linked anywhere, so it&#x27;s purely just a standalone object; in some circumstances, that may be preferable.</p><pre id="78c85bab-fd87-4a4d-a582-4d604ebcb24c" class="code"><code>homework.topic;
// &quot;JS&quot;

otherHomework.topic;
// &quot;JS&quot;

otherHomework.topic = &quot;Math&quot;; // creates a property topic on otherHomework
otherHomework.topic; // this call no longer needs to be delegated
// &quot;Math&quot;

homework.topic;
// &quot;JS&quot; -- not &quot;Math</code></pre><p id="9193117d-5aa1-4c7b-88eb-3ee2382e0e71" class="">The <code>topic</code> on <code>otherHomework</code> is &quot;shadowing&quot; the property of the same name on the <code>homework</code> object in the chain.</p><figure id="429c7b81-42fa-40e6-bd0f-9700a20dd01f" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2022.png"><img style="width:240px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2022.png"/></a></figure><p id="cf623d52-c5af-488f-82ed-6c511a2cd5b6" class="">Fig. 5: Shadowed property &#x27;topic&#x27;</p><h1 id="dce0c1b0-dbfa-4f2a-b858-f3e6096af4b6" class="block-color-red_background">Chapter 1.4: The Bigger Picture</h1><h3 id="acc37eb4-ce04-4c7d-a125-65eea615342a" class="">Pillar 1: Scope and Closure</h3><p id="b93c3674-4a9a-49ee-8f45-fe76c3a0c2fd" class="">Scopes nest inside each other, and for any given expression or statement, only variables at that level of scope nesting, or in higher/outer scopes, are accessible; variables from lower/inner scopes are hidden and inaccessible.</p><p id="083e72da-7604-4f3f-963d-18146ec6734e" class="">This is how scopes behave in most languages, which is called lexical scope. The scope unit boundaries, and how variables are organized in them, is determined at the time the program is parsed (compiled). In other words, it&#x27;s an author-time decision: where you locate a function/scope in the program determines what the scope structure of that part of the program will be.</p><p id="b05ac31d-7016-4ec0-88ad-f19bbe3cf62d" class="">JS is lexically scoped, though many claim it isn&#x27;t, because of two particular characteristics of its model that are not present in other lexically scoped languages.</p><p id="2657014e-e341-4bb4-ae50-867068f5f1e8" class="">The first is commonly called <em>hoisting</em>: when all variables declared anywhere in a scope are treated as if they&#x27;re declared at the beginning of the scope. The other is that <code>var</code>-declared variables are function scoped, even if they appear inside a block.</p><p id="1324af01-e99d-44e6-a757-ecfb1a3768f5" class="">Neither hoisting nor function-scoped <code>var</code> are sufficient to back the claim that JS is not lexically scoped. <code>let</code>/<code>const</code> declarations have a peculiar error behavior called the &quot;Temporal Dead Zone&quot; (TDZ) which results in observable but unusable variables. Though TDZ can be strange to encounter, it&#x27;s <em>also</em> not an invalidation of lexical scoping. All of these are just unique parts of the language that should be learned and understood by all JS developers.</p><p id="52c63935-163f-48dc-b881-29b93fafe261" class="">Closure is a natural result of lexical scope when the language has functions as first-class values, as JS does. When a function makes reference to variables from an outer scope, and that function is passed around as a value and executed in other scopes, it maintains access to its original scope variables; this is closure.</p><p id="f7763188-91c8-4077-a6bc-0ced99e83f95" class="">Across all of programming, but especially in JS, closure drives many of the most important programming patterns, including modules. As I see it, modules are as <em>with the grain</em> as you can get, when it comes to code organization in JS.</p><h3 id="abc4f401-672d-4fb2-98ca-8118a9426510" class="">Pillar 2: Prototypes</h3><p id="4a7ecd83-5148-4b68-813c-219f9b715216" class="">JS is one of very few languages where you have the option to create objects directly and explicitly, without first defining their structure in a class.</p><p id="c7b0f227-21c8-437b-9728-37bfdbb1e18b" class="">For many years, people implemented the class design pattern on top of prototypes—so-called &quot;prototypal inheritance&quot; (see Appendix A, &quot;Prototypal &#x27;Classes&#x27;&quot;)—and then with the advent of ES6&#x27;s <code>class</code> keyword, the language doubled-down on its inclination toward OO/class-style programming.</p><p id="235f85c5-f44b-42ea-8654-295a4b1c33d6" class="">But I think that focus has obscured the beauty and power of the prototype system: the ability for two objects to simply connect with each other and cooperate dynamically (during function/method execution) through sharing a <code>this</code> context.</p><p id="8141d5af-dfb5-47a7-b8cc-7cda6d5c4940" class="">Classes are just one pattern you can build on top of such power. But another approach, in a very different direction, is to simply embrace objects as objects, forget classes altogether, and let objects cooperate through the prototype chain. This is called <em>behavior delegation</em>. I think delegation is more powerful than class inheritance, as a means for organizing behavior and data in our programs.</p><p id="ecfed339-c464-490e-876b-7c3a4bdd1509" class="">But class inheritance gets almost all the attention. And the rest goes to functional programming (FP), as the sort of &quot;anti-class&quot; way of designing programs. This saddens me, because it snuffs out any chance for exploration of delegation as a viable alternative.</p><p id="0b8a3669-89c0-48b5-87b4-be844eecf4ee" class="">I encourage you to spend plenty of time deep in Book 3, <em>Objects &amp; Classes</em>, to see how object delegation holds far more potential than we&#x27;ve perhaps realized. This isn&#x27;t an anti-<code>class</code> message, but it is intentionally a &quot;classes aren&#x27;t the only way to use objects&quot; message that I want more JS developers to consider.</p><p id="b2fe37d5-31bc-449c-b9c2-ac9ad1a364b5" class="">Object delegation is, I would argue, far more <em>with the grain</em> of JS, than classes (more on <em>grains</em> in a bit).</p><h3 id="116f292e-a95e-4c48-890e-3d7b764253c6" class="">Pillar 3: Types and Coercion</h3><p id="7bb4463d-0c42-4e30-b3d5-e9b590c232a9" class="">The third pillar of JS is by far the most overlooked part of JS&#x27;s nature.</p><p id="1afcd237-cbe3-4c57-b80f-b3ad24463c8a" class="">The vast majority of developers have strong misconceptions about how <em>types</em> work in programming languages, and especially how they work in JS. A tidal wave of interest in the broader JS community has begun to shift to &quot;static typing&quot; approaches, using type-aware tooling like TypeScript or Flow.</p><p id="7d2fd2fa-90af-47da-ae15-3e174a8d0b40" class="">I agree that JS developers should learn more about types, and should learn more about how JS manages type conversions. I also agree that type-aware tooling can help developers, assuming they have gained and used this knowledge in the first place!</p><p id="8036eae6-a62f-4e7a-8dcf-d249037eb892" class="">But I don&#x27;t agree at all that the inevitable conclusion of this is to decide JS&#x27;s type mechanism is bad and that we need to cover up JS&#x27;s types with solutions outside the language. We don&#x27;t have to follow the &quot;static typing&quot; way to be smart and solid with types in our programs. There are other options, if you&#x27;re just willing to go <em>against the grain</em> of the crowd, and <em>with the grain</em> of JS (again, more on that to come).</p><p id="9ba74daf-e32e-4d04-8716-05a51ffae7ea" class="">Arguably, this pillar is more important than the other two, in the sense that no JS program will do anything useful if it doesn&#x27;t properly leverage JS&#x27;s value types, as well as the conversion (coercion) of values between types.</p><p id="9d2fd19a-c8da-4c89-858b-c22e22e8e515" class="">Even if you love TypeScript/Flow, you are not going to get the most out of those tools or coding approaches if you aren&#x27;t deeply familiar with how the language itself manages value types.</p><h1 id="84abd800-25d5-4ad6-bd7a-79686fe0c580" class="block-color-red_background">Chapter 1.Appendix A Exploring Further</h1><p id="286e2e58-088c-486e-916c-584f18f7ec31" class="">Function Forms lots of arrow function syntax: refer to </p><p id="ab8f6546-eb9d-4bf4-b44d-df8126027cf2" class=""><strong>Coercive Conditional Comparison</strong></p><pre id="9b0a3655-4061-4fbf-ab5b-c8137478fa58" class="code"><code>var x = &quot;hello&quot;;

if (x) {
    // will run!
}

if (x == true) {
    // won&#x27;t run :(
}</code></pre><pre id="d8884746-af60-41f3-a3dd-bc7d7c053996" class="code"><code>var x = &quot;hello&quot;;

if (Boolean(x) == true) {
    // will run
}

// which is the same as:

if (Boolean(x) === true) {
    // will run
}</code></pre><p id="3f23c1d6-32b1-47da-8440-3bb30938f60f" class=""><strong>prototype</strong> is preferred over the class syntax to create prototype/inheritance</p><pre id="134f24f9-5d95-4b3b-8e6a-0414340952ef" class="code"><code>function Classroom() {
    // ..
}

Classroom.prototype.welcome = function hello() {
    console.log(&quot;Welcome, students!&quot;);
};

var mathClass = new Classroom();

mathClass.welcome();
// Welcome, students!</code></pre><p id="7ccff044-76c5-4bc5-af80-01161a59d5a9" class="">All functions by default reference an empty object at a property named <code>prototype</code>. Despite the confusing naming, this is <strong>not</strong> the function&#x27;s <em>prototype</em> (where the function is prototype linked to), but rather the prototype object to <em>link to</em> when other objects are created by calling the function with <code>new</code>.</p><p id="ab868976-e132-4065-9016-3e1bf4ecb350" class="">We add a <code>welcome</code> property on that empty object (called <code>Classroom.prototype</code>), pointing at the <code>hello()</code> function.</p><p id="a33acf54-691f-4261-a855-1e7cd9f7e711" class="">Then <code>new Classroom()</code> creates a new object (assigned to <code>mathClass</code>), and prototype links it to the existing <code>Classroom.prototype</code> object.</p><p id="ea0e1870-cd7e-4a6a-afc4-7068b53b8fd6" class="">Though <code>mathClass</code> does not have a <code>welcome()</code> property/function, it successfully delegates to the function <code>Classroom.prototype.welcome()</code>.</p><p id="7d4efeaa-550b-4b03-8af5-af707ede12d7" class="">This &quot;prototypal class&quot; pattern is now strongly discouraged, in favor of using ES6&#x27;s <code>class</code> mechanism:</p><pre id="9f1bb875-d7c9-48a6-8332-522b4f42ef6d" class="code"><code>class Classroom {
    constructor() {
        // ..
    }

    welcome() {
        console.log(&quot;Welcome, students!&quot;);
    }
}

var mathClass = new Classroom();

mathClass.welcome();
// Welcome, students!</code></pre><p id="1d0df2e5-74f1-4794-b33e-0ae655f9a9a8" class="">
</p><h1 id="427bda99-cacc-446d-8903-8e0244016e7f" class="block-color-red_background">Chapter 2 Scope and Closures</h1><h1 id="a8e64a7d-dd7f-48d2-bac4-f7e964bb5e74" class="">Chapter 2.1 What&#x27;s the scope</h1><p id="60644521-9366-4351-affe-ff3daaa42b08" class="">classical compiler theory:</p><ol type="1" id="a8cdbe86-af8f-4786-85db-c6a3bd25d81d" class="numbered-list" start="1"><li><strong>Tokenizing/Lexing:</strong> breaking up a string of characters into meaningful (to the language) chunks, called tokens. For instance, consider the program: <code>var a = 2;</code>. This program would likely be broken up into the following tokens: <code>var</code>, <code>a</code>, <code>=</code>, <code>2</code>, and <code>;</code>. Whitespace may or may not be persisted as a token, depending on whether it&#x27;s meaningful or not.<p id="e311474d-54c6-42e6-bd2d-cdcde026c0a5" class="">(The difference between tokenizing and lexing is subtle and academic, but it centers on whether or not these tokens are identified in a <em>stateless</em> or <em>stateful</em> way. Put simply, if the tokenizer were to invoke stateful parsing rules to figure out whether <code>a</code> should be considered a distinct token or just part of another token, <em>that</em> would be <strong>lexing</strong>.)</p></li></ol><ol type="1" id="8bef3950-bdb4-462f-9028-234d4bb5e238" class="numbered-list" start="2"><li><strong>Parsing:</strong> taking a stream (array) of tokens and turning it into a tree of nested elements, which collectively represent the grammatical structure of the program. This is called an Abstract Syntax Tree (AST).<p id="fe5017c3-28a3-4579-ab0b-9da178475aba" class="">For example, the tree for <code>var a = 2;</code> might start with a top-level node called <code>VariableDeclaration</code>, with a child node called <code>Identifier</code> (whose value is <code>a</code>), and another child called <code>AssignmentExpression</code> which itself has a child called <code>NumericLiteral</code> (whose value is <code>2</code>).</p></li></ol><ol type="1" id="53f4a077-7a2c-4fbe-875d-be9824fa049b" class="numbered-list" start="3"><li><strong>Code Generation:</strong> taking an AST and turning it into executable code. This part varies greatly depending on the language, the platform it&#x27;s targeting, and other factors.<p id="5d007e83-cfab-46eb-98a0-e6b6e267d898" class="">The JS engine takes the just described AST for <code>var a = 2;</code> and turns it into a set of machine instructions to actually <em>create</em> a variable called <code>a</code> (including reserving memory, etc.), and then store a value into <code>a</code>.</p></li></ol><p id="217133d4-359a-47ff-a557-bbd4d3c55cdf" class="">JS programs occur in (at least) two phases: <mark class="highlight-orange_background"><strong>parsing/compilation first, then execution</strong></mark>. JS compilation usually must happen in mere microseconds (or less!) right before the code is executed.</p><p id="a52aa109-bcd5-4c6e-8ac7-b81fb68313e8" class="">There are three program characteristics you can observe to prove this to yourself: syntax errors, early errors, and hoisting.<div class="indented"><p id="fc01ca3b-8b6f-42f5-aa07-e9b07c974986" class=""><strong>syntax errors </strong>are thrown before code was executed → the code must first be fully parsed before any execution occurs <div class="indented"><ol type="1" id="d65621b4-44a4-4f39-914a-a9c57ece2adb" class="numbered-list" start="1"><li>// SyntaxError: unexpected token .</li></ol><ol type="1" id="ee858444-42a6-40a4-9b21-0afc0f6ef08d" class="numbered-list" start="2"><li>// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</li></ol><ol type="1" id="ff7a0cd3-9fb9-40f2-8230-8929b71ef884" class="numbered-list" start="3"><li>//ReferenceError: Cannot access &#x27;greeting&#x27; before initialization — refer to Temporal Dead Zone (TDZ)</li></ol></div></p></div></p><h3 id="193124cb-e13d-4c9d-9efa-9e7ebf97c5b5" class="">Compiler Speak</h3><p id="3d528aa4-321e-422b-875d-a4b0b451a3a0" class="">Other than declarations, all occurrences of variables/identifiers in a program serve in one of two &quot;roles&quot;: either they&#x27;re the target of an assignment or they&#x27;re the source of a value.</p><p id="65eff35d-8f2c-4419-b191-3ddfbbe54a71" class="">LHS(left hand side) = target. RHS(right hand side) = source</p><p id="f14850d7-864a-473b-b0d8-5b9704abdd86" class="">How do you know if a variable is a target? Check if there is a value that is being assigned to it; if so, it&#x27;s a target. If not, then the variable is a source.</p><h3 id="cebdb350-c7c0-46dd-a354-efb9d1899bd3" class="">Targets/ target references</h3><figure id="6da8dab5-fa47-4985-96fa-a37db3f3dbe3" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2023.png"><img style="width:539px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2023.png"/></a></figure><p id="8a6bf5af-3b35-4e71-a143-20e829639df1" class=""><code>function getStudentName(studentID) {</code></p><p id="99fe9af9-375f-41da-88db-d3cd6147ae03" class="">A <code>function</code> declaration is a special case of a <em>target</em> reference. You can think of it sort of like <code>var getStudentName = function(studentID)</code>, but that&#x27;s not exactly accurate. An identifier <code>getStudentName</code> is declared (at compile time), but the <code>= function(studentID)</code> part is also handled at compilation; the association between <code>getStudentName</code> and the function is automatically set up at the beginning of the scope rather than waiting for an <code>=</code> assignment statement to be executed.</p><p id="60694e1c-2ab8-4877-8865-f176748506d4" class="">This automatic association of function and variable is referred to as &quot;function hoisting&quot;</p><h3 id="4ad71bf9-cf67-4719-a666-9fc96f5c50be" class=""><strong>Sources/ source references</strong></h3><p id="7a9188e2-af73-4b9a-b758-12c35dabbcd0" class="">So we&#x27;ve identified all five <em>target</em> references in the program. The other variable references must then be <em>source</em> references (because that&#x27;s the only other option!).</p><p id="44acea95-1442-497f-9f10-94ed1863c0cb" class="">In <code>for (let student of students)</code>, we said that <code>student</code> is a <em>target</em>, but <code>students</code> is a <em>source</em> reference. In the statement <code>if (student.id == studentID)</code>, both <code>student</code> and <code>studentID</code> are <em>source</em> references. <code>student</code> is also a <em>source</em> reference in <code>return student.name</code>.</p><p id="70af8d25-001c-4131-9abe-4c8a422e3c87" class="">In <code>getStudentName(73)</code>, <code>getStudentName</code> is a <em>source</em> reference (which we hope resolves to a function reference value). In <code>console.log(nextStudent)</code>, <code>console</code> is a <em>source</em> reference, as is <code>nextStudent</code>.</p><h3 id="a8d8863e-3f24-44e3-81af-549bf92dbcec" class="">Cheating: Runtime Scope Modifications</h3><p id="74886df8-1f5a-4d87-89ce-31f0fc5545c0" class="">scope is determined as the program is compiled. in non-strict-mode,  two ways to cheat this rule, modifying a program&#x27;s scopes during runtime. They are dangerous and confusing.</p><p id="ec0c9d53-1b8a-474a-92d1-dafb849d3587" class="">The <code>eval(..)</code> function receives a string of code to compile and execute on the fly during the program runtime. If that string of code has a <code>var</code> or <code>function</code> declaration in it, those declarations will modify the current scope that the <code>eval(..)</code> is currently executing in:</p><pre id="841ad621-3811-45ec-81e3-56097827ed76" class="code"><code>function badIdea() {
    eval(&quot;var oops = &#x27;Ugh!&#x27;;&quot;);
    console.log(oops);
}
badIdea();   // Ugh!</code></pre><p id="af012cdd-ca22-4570-b868-66c567218679" class="">If the <code>eval(..)</code> had not been present, the <code>oops</code> variable in <code>console.log(oops)</code> would not exist, and would throw a <code>ReferenceError</code>. But <code>eval(..)</code> modifies the scope of the <code>badIdea()</code> function at runtime. This is bad for many reasons, including the performance hit of modifying the already compiled and optimized scope, every time <code>badIdea()</code> runs.</p><p id="cf43d8c6-4192-492e-a387-e3e7d1b9de3f" class="">The second cheat is the <code>with</code> keyword, which essentially dynamically turns an object into a local scope—its properties are treated as identifiers in that new scope&#x27;s block:</p><pre id="ed92d3bc-ae5e-47d7-bde1-1807445162d5" class="code"><code>var badIdea = { oops: &quot;Ugh!&quot; };

with (badIdea) {
    console.log(oops);   // Ugh!
}</code></pre><p id="af405807-2758-4659-ad5c-80a642687eb3" class="">The global scope was not modified here, but <code>badIdea</code> was turned into a scope at runtime rather than compile time, and its property <code>oops</code> becomes a variable in that scope. Again, this is a terrible idea, for performance and readability reasons.</p><p id="84ab188f-f761-4faa-a051-5bb11e0e5883" class="">At all costs, avoid <code>eval(..)</code> (at least, <code>eval(..)</code> creating declarations) and <code>with</code>. Again, neither of these cheats is available in strict-mode, so if you just use strict-mode (you should!) then the temptation goes away!</p><p id="0392b54f-4102-41cf-9323-7a14e1d7d588" class="">JS&#x27;s &quot;lexical scope&quot;(scope is determined at lexing of compile time) is controlled entirely by the placement of functions, blocks, and variable declarations, in relation to one another.</p><p id="07836072-e2f0-4872-8809-f7f47a2e3791" class="">If you place a variable declaration inside a function, the compiler handles this declaration as it&#x27;s parsing the function, and associates that declaration with the function&#x27;s scope. If a variable is block-scope declared (<code>let</code> / <code>const</code>), then it&#x27;s associated with the nearest enclosing <code>{ .. }</code> block, rather than its enclosing function (as with <code>var</code>).</p><p id="3390a0f1-fb29-446d-9f88-902caccf0822" class="">Furthermore, a reference (<em>target</em> or <em>source</em> role) for a variable must be resolved as coming from one of the scopes that are <em>lexically available</em> to it; otherwise the variable is said to be &quot;undeclared&quot; (which usually results in an error!). If the variable is not declared in the current scope, the next outer/enclosing scope will be consulted. This process of stepping out one level of scope nesting continues until either a matching variable declaration can be found, or the global scope is reached and there&#x27;s nowhere else to go.</p><p id="e4091ecd-a64e-49e9-ac24-78afb82b817d" class="">It&#x27;s important to note that compilation doesn&#x27;t actually <em>do anything</em> in terms of reserving memory for scopes and variables. None of the program has been executed yet.</p><p id="daa2827e-0ac5-4e4e-bd05-f8882e26a77b" class="">Instead, compilation creates a map of all the lexical scopes that lays out what the program will need while it executes. You can think of this plan as inserted code for use at runtime, which defines all the scopes (aka, &quot;lexical environments&quot;) and registers all the identifiers (variables) for each scope.</p><p id="9b96151f-dbbd-4c0e-8423-7699ec803f36" class="">In other words, <mark class="highlight-yellow_background"><strong>while scopes are identified during compilation, they&#x27;re not actually created until runtime, each time a scope needs to run.</strong></mark><strong> </strong>In the next chapter, we&#x27;ll sketch out the conceptual foundations for lexical scope.</p><h1 id="4f06bac7-7a42-459a-99e6-2526158d4f93" class="">Ch2.2 Illustrating Lexical Scope</h1><p id="1d5e3460-fbe3-4aff-921a-1b56aea4a66c" class=""><strong>marbles &amp; bubbles</strong></p><p id="4acca18c-19ca-46d5-9ac4-3fe15a79fc14" class="">Scope bubbles are determined during compilation based on where the functions/blocks of scope are written, the nesting inside each other, and so on. Each scope bubble is entirely contained within its parent scope bubble—a scope is never partially in two different outer scopes.</p><p id="58405dd4-31f5-4981-a726-2c638ccca923" class="">Each marble (variable/identifier) is colored based on which bubble (bucket) it&#x27;s declared in, not the color of the scope it may be accessed from (e.g., <code>students</code> on line 9 and <code>studentID</code> on line 10).</p><p id="2d8c2afc-ac81-4a70-9025-1aa7d81a7536" class=""><strong>Conversation among friends</strong></p><p id="afb11afb-5c1a-430f-8a54-005bb807b4c4" class="">Let&#x27;s now meet the members of the JS engine that will have conversations as they process our program:</p><ul id="4a3ff449-9cbf-4b47-9933-5ad4fd016895" class="bulleted-list"><li style="list-style-type:disc"><em>Engine</em>: responsible for start-to-finish compilation and execution of our JavaScript program.</li></ul><ul id="031d4795-e5c2-48ff-8389-69bcc7fb689e" class="bulleted-list"><li style="list-style-type:disc"><em>Compiler</em>: one of <em>Engine</em>&#x27;s friends; handles all the dirty work of parsing and code-generation (see previous section).</li></ul><ul id="141f91bc-1bd0-4dac-9445-95191292cb84" class="bulleted-list"><li style="list-style-type:disc"><em>Scope Manager</em>: another friend of <em>Engine</em>; collects and maintains a lookup list of all the declared variables/identifiers, and enforces a set of rules as to how these are accessible to currently executing code.</li></ul><p id="1fe0c1a9-351d-409f-bec0-837bd191f7b0" class="">var students = [ .. ] declaration and initialization-assignment parts:</p><p id="02ddc442-d772-427f-8bd1-a0433acd6c5c" class="">Here&#x27;s the steps <em>Compiler</em> will follow to handle that statement:</p><ol type="1" id="9f62cf62-9ea6-41ea-86f6-08034d02a423" class="numbered-list" start="1"><li>Encountering <code>var students</code>, <em>Compiler</em> will ask <em>Scope Manager</em> to see if a variable named <code>students</code> already exists for that particular scope bucket. If so, <em>Compiler</em> would ignore this declaration and move on. Otherwise, <em>Compiler</em> will produce code that (at execution time) asks <em>Scope Manager</em> to create a new variable called <code>students</code> in that scope bucket.</li></ol><ol type="1" id="95e7b7cb-a943-4748-9755-3bb08f9778df" class="numbered-list" start="2"><li><em>Compiler</em> then produces code for <em>Engine</em> to later execute, to handle the <code>students = []</code> assignment. The code <em>Engine</em> runs will first ask <em>Scope Manager</em> if there is a variable called <code>students</code> accessible in the current scope bucket. If not, <em>Engine</em> keeps looking elsewhere (see &quot;Nested Scope&quot; below). Once <em>Engine</em> finds a variable, it assigns the reference of the <code>[ .. ]</code> array to it.</li></ol><p id="43129d3a-85e7-4680-85df-a79851f4f678" class="">In conversational form<span style="border-bottom:0.05em solid">, the first phase of compilation for the program might play out between </span><span style="border-bottom:0.05em solid"><em>Compiler</em></span><span style="border-bottom:0.05em solid"> and </span><span style="border-bottom:0.05em solid"><em>Scope Manager</em></span><span style="border-bottom:0.05em solid"> like this:</span></p><p id="9923da13-32fd-4c88-a966-4b74279c00f4" class="">Compiler: Hey, Scope Manager (of the global scope), I found a formal declaration for an identifier called students, ever heard of it?</p><p id="88e77f51-fe69-4004-a358-a0ee097d0816" class="">(Global) Scope Manager: Nope, never heard of it, so I just created it for you.</p><p id="654a63ef-3ffd-4cee-90fb-e8e7efa01918" class="">Compiler: Hey, Scope Manager, I found a formal declaration for an identifier called getStudentName, ever heard of it?</p><p id="85814d3a-c140-44bc-927b-f57f38137620" class="">(Global) Scope Manager: Nope, but I just created it for you.</p><p id="436cb4da-98e9-4542-aa15-2a005a8e18e2" class="">Compiler: Hey, Scope Manager, getStudentName points to a function, so we need a new scope bucket.</p><p id="dc225bdd-f47a-489a-9772-a7ca6e6dddeb" class="">(Function) Scope Manager: Got it, here&#x27;s the scope bucket.</p><p id="76bdb5a4-3e2b-467f-b652-f8fa06397e0b" class="">Compiler: Hey, Scope Manager (of the function), I found a formal parameter declaration for studentID, ever heard of it?</p><p id="e02e231f-4f08-4644-b9cb-a9a3bf95fc4a" class="">(Function) Scope Manager: Nope, but now it&#x27;s created in this scope.</p><p id="245918e9-1aeb-4c57-b322-065f09cdc23c" class="">Compiler: Hey, Scope Manager (of the function), I found a for-loop that will need its own scope bucket.</p><p id="d9bfb1c2-e2c2-4328-a59d-ce70bd23c4e2" class="">...</p><p id="7b43bb59-c876-4aaa-abbf-1c7ff4dd85c8" class="">The conversation is a question-and-answer exchange, where <strong>Compiler</strong> asks the current <em>Scope Manager</em> if an encountered identifier declaration has already been encountered. If &quot;no,&quot; <em>Scope Manager</em> creates that variable in that scope. If the answer is &quot;yes,&quot; then it&#x27;s effectively skipped over since there&#x27;s nothing more for that <em>Scope Manager</em> to do.</p><p id="dfb087ac-05af-450a-bac7-9cd055daac46" class=""><em>Compiler</em> also signals when it runs across functions or block scopes, so that a new scope bucket and <em>Scope Manager</em> can be instantiated.</p><p id="25a0be30-e722-4cd1-8582-dbf3415d37f1" class="">Later, <span style="border-bottom:0.05em solid">when it comes to execution of the program, the conversation will shift to </span><span style="border-bottom:0.05em solid"><em>Engine</em></span><span style="border-bottom:0.05em solid"> and </span><span style="border-bottom:0.05em solid"><em>Scope Manager</em></span><span style="border-bottom:0.05em solid">, and might play out like this:</span></p><p id="aa37f76b-189d-4e36-946f-571120e891eb" class="">Engine: Hey, Scope Manager (of the global scope), before we begin, can you look up the identifier getStudentName so I can assign this function to it?</p><p id="9a2a455f-acc6-4a6d-8b23-00f1f50629b1" class="">(Global) Scope Manager: Yep, here&#x27;s the variable.</p><p id="9dc89902-6060-466a-bc32-a8adba1d3c8a" class="">Engine: Hey, Scope Manager, I found a target reference for students, ever heard of it?</p><p id="d0b589f1-db6e-47bf-b479-46acacc57064" class="">(Global) Scope Manager: Yes, it was formally declared for this scope, so here it is.</p><p id="96ccc642-fa14-4e85-b943-48f558973cca" class="">Engine: Thanks, I&#x27;m initializing students to undefined, so it&#x27;s ready to use.</p><p id="390095fd-5409-4d41-86d1-b9070232b5f4" class="">Hey, Scope Manager (of the global scope), I found a target reference for nextStudent, ever heard of it?</p><p id="6cfc71cb-f51f-4b21-9872-6b7301c2573e" class="">(Global) Scope Manager: Yes, it was formally declared for this scope, so here it is.</p><p id="ae6e1dac-1bbc-4e13-b7cf-f31dbd5dd6ed" class="">Engine: Thanks, I&#x27;m initializing nextStudent to undefined, so it&#x27;s ready to use.</p><p id="87fb43cc-21e7-427f-b467-fbdefccdaebe" class="">Hey, Scope Manager (of the global scope), I found a source reference for getStudentName, ever heard of it?</p><p id="8bfd28e4-9f70-43ed-abe2-d82aa95fee6d" class="">(Global) Scope Manager: Yes, it was formally declared for this scope. Here it is.</p><p id="4d8c5c9f-4797-4955-ae45-4b1bc994b329" class="">Engine: Great, the value in getStudentName is a function, so I&#x27;m going to execute it.</p><p id="0db272bf-b4f8-4652-9e39-8833609e3542" class="">Engine: Hey, Scope Manager, now we need to instantiate the function&#x27;s scope.</p><p id="cd73d67b-8c3e-4916-9039-d4ba1b8aa301" class="">To review and summarize how a statement like <code>var students = [ .. ]</code> is processed, in two distinct steps:</p><ol type="1" id="21db3bd8-ee2e-429d-98c5-78752852bde1" class="numbered-list" start="1"><li><em>Compiler</em> sets up the declaration of the scope variable (since it wasn&#x27;t previously declared in the current scope).</li></ol><ol type="1" id="fa006f01-08e4-42eb-928a-8cb28da18844" class="numbered-list" start="2"><li>While <em>Engine</em> is executing, to process the assignment part of the statement, <em>Engine</em> asks <em>Scope Manager</em> to look up the variable, initializes it to <code>undefined</code> so it&#x27;s ready to use, and then assigns the array value to it.</li></ol><h2 id="11b2d256-9ac2-4375-be60-9d5987849519" class=""><strong>Nested Scope</strong></h2><p id="5735d0a1-60e2-4da0-bf9d-d14fd296b838" class="">When it comes time to execute the <code>getStudentName()</code> function, <em>Engine</em> asks for a <em>Scope Manager</em> instance for that function&#x27;s scope, and it will then proceed to look up the parameter (<code>studentID</code>) to assign the <code>73</code> argument value to, and so on.</p><p id="747e399b-3a49-48db-a2a5-8035d89ea658" class="">The function scope for <code>getStudentName(..)</code> is nested inside the global scope. The block scope of the <code>for</code>-loop is similarly nested inside that function scope. Scopes can be lexically nested to any arbitrary depth as the program defines.</p><p id="04233750-1b0e-48f9-a096-bf26b1fec749" class="">Each scope gets its own <em>Scope Manager</em> instance each time that scope is executed (one or more times). Each scope automatically has all its identifiers registered at the start of the scope being executed (this is called &quot;variable hoisting&quot;; see Chapter 5).</p><p id="31da9556-9ad0-43b1-93f0-e71a1a984c82" class="">At the beginning of a scope, if any identifier came from a <code>function</code> declaration, that variable is automatically initialized to its associated function reference. And if any identifier came from a <code>var</code> declaration (as opposed to <code>let</code>/<code>const</code>), that variable is automatically initialized to <code>undefined</code> so that it can be used; otherwise, the variable remains uninitialized (aka, in its &quot;TDZ,&quot; see Chapter 5) and cannot be used until its full declaration-and-initialization are executed.</p><p id="8e54144d-aa5e-4135-b5cf-68aa50bb9962" class="">In the <code>for (let student of students) {</code> statement, <code>students</code> is a <em>source</em> reference that must be looked up. But how will that lookup be handled, since the scope of the function will not find such an identifier?</p><p id="38b48caa-e17a-4098-a7aa-0fc254b2c90b" class="">To explain, let&#x27;s imagine that bit of conversation playing out like this:</p><p id="0f467317-cc78-45b8-abab-685f356ea94e" class="">Engine: Hey, Scope Manager (for the function), I have a source reference for students, ever heard of it?</p><p id="d3acbb5e-cbdb-4a87-a78e-25f3b3ede88e" class="">(Function) Scope Manager: Nope, never heard of it. Try the next outer scope.</p><p id="f0469e4a-de08-4ba4-85d7-49e0557f24bf" class="">Engine: Hey, Scope Manager (for the global scope), I have a source reference for students, ever heard of it?</p><p id="f849961d-eabe-430b-8300-0266740dc845" class="">(Global) Scope Manager: Yep, it was formally declared, here it is.</p><p id="b15df5d9-775b-4efa-86d3-00fdb98dd602" class="">...</p><p id="c6679d02-a251-4074-875f-95a60d637b0a" class="">One of the key aspects of lexical scope is that any time an identifier reference cannot be found in the current scope, the next outer scope in the nesting is consulted; that process is repeated until an answer is found or there are no more scopes to consult.</p><h3 id="69c03f5b-e68d-4c71-8d48-a7b06dbaa873" class=""><strong>Lookup Failures</strong></h3><p id="2322f7cb-1fcf-4b08-94a4-b79acc4f3c2f" class="">When <em>Engine</em> exhausts all <em>lexically available</em> scopes (moving outward) and still cannot resolve the lookup of an identifier, an error condition then exists. However, depending on the mode of the program (strict-mode or not) and the role of the variable (i.e., <em>target</em> vs. <em>source</em>; see Chapter 1), this error condition will be handled differently.</p><h3 id="02737d8a-1c79-4abc-b567-01e21b25ba93" class=""><strong>Undefined Mess</strong></h3><p id="b69b68ce-68ec-489e-8056-c4874219744b" class="">If the variable is a <em>source</em>, an unresolved identifier lookup is considered an undeclared (unknown, missing) variable, which always results in a <code>ReferenceError</code> being thrown. Also, if the variable is a <em>target</em>, and the code at that moment is running in strict-mode, the variable is considered undeclared and similarly throws a <code>ReferenceError</code>.</p><p id="3736555f-1691-4914-8278-c0f3bbe595b1" class="">The error message for an undeclared variable condition, in most JS environments, will look like, &quot;Reference Error: XYZ is not defined.&quot; The phrase &quot;not defined&quot; seems almost identical to the word &quot;undefined,&quot; as far as the English language goes. But these two are very different in JS, and this error message unfortunately creates a persistent confusion.</p><p id="b2feb1d9-57d2-4715-a2be-cbfea189b525" class="">&quot;Not defined&quot; really means &quot;not declared&quot;—or, rather, &quot;undeclared,&quot; as in a variable that has no matching formal declaration in any <em>lexically available</em> scope. By contrast, &quot;undefined&quot; really means a variable was found (declared), but the variable otherwise has no other value in it at the moment, so it defaults to the <code>undefined</code> value.</p><p id="5a0b6d98-1d2c-4560-89c3-b9c46b73e141" class="">To perpetuate the confusion even further, JS&#x27;s <code>typeof</code> operator returns the string <code>&quot;undefined&quot;</code> for variable references in either state:</p><p id="91fba66a-1d46-49e1-af20-db70afd55cee" class=""><code>var studentName;
typeof studentName;     // &quot;undefined&quot;

typeof doesntExist;     // &quot;undefined&quot;</code></p><p id="a0552350-e576-451b-88ee-d142a7b8413d" class="">These two variable references are in very different conditions, but JS sure does muddy the waters. The terminology mess is confusing and terribly unfortunate. Unfortunately, JS developers just have to pay close attention to not mix up <em>which kind</em> of &quot;undefined&quot; they&#x27;re dealing with!</p><p id="447651e9-57b1-40bd-bad1-ede63cb3dffd" class="">if the variable is a target and strict-mode is not in effect, a confusing and surprising legacy behavior kicks in. The troublesome outcome is that the global scope&#x27;s Scope Manager will just create an accidental global variable to fulfill that target assignment!</p><h1 id="05e1e62d-80b2-4c78-91d2-05b2d5df87ee" class="">Chapter 2.3 The Scope Chain</h1><h3 id="b3f1f63a-0efe-4a45-adb7-76038914d71b" class="">&quot;Lookup&quot; Is (Mostly) Conceptual</h3><p id="71d30aa5-d71d-4519-9802-188109eeb9ef" class="">Engine (from Chapter 2) doesn&#x27;t need to lookup through a bunch of scopes to figure out which scope bucket a variable comes from. That information is already known! Avoiding the need for a runtime lookup is a key optimization benefit of lexical scope. The runtime operates more performantly without spending time on all these lookups.</p><p id="63e064c1-56b7-4e60-91cc-eb643697c642" class="">exception: The scope of variables from other programs is determined at runtime, once pre variable. Any reference to a variable that&#x27;s initially undeclared is left as an uncolored marble during that file&#x27;s compilation; this color cannot be determined until other relevant file(s) have been compiled and the application runtime commences. That deferred lookup will eventually resolve the color to whichever scope the variable is found in (likely the global scope).</p><h3 id="bbb14abf-8b1c-4e59-bd67-e403ef887d91" class="">Shadowing</h3><pre id="ca832d7e-7923-4429-8be1-0436ff8ff0ce" class="code"><code>var studentName = &quot;Suzy&quot;;

function printStudent(studentName) {
    studentName = studentName.toUpperCase();
    console.log(studentName);
}

printStudent(&quot;Frank&quot;);
// FRANK

printStudent(studentName);
// SUZY

console.log(studentName);
// Suzy</code></pre><p id="59dedadf-e8ee-4d5d-939e-c08a309fdb27" class="">The <code>studentName</code> variable on line 1 (the <code>var studentName = ..</code> statement) creates a RED(1) marble. The same named variable is declared as a BLUE(2) marble on line 3, the parameter in the <code>printStudent(..)</code> function definition.</p><p id="db4c3f75-1567-4c0b-8227-4cff2b32ef35" class=""><mark class="highlight-yellow_background">This is a key aspect of lexical scope behavior, called </mark><mark class="highlight-yellow_background"><em>shadowing</em></mark><mark class="highlight-yellow_background">. The BLUE(2) </mark><mark class="highlight-yellow_background"><code>studentName</code></mark><mark class="highlight-yellow_background"> variable (parameter) shadows the RED(1) </mark><mark class="highlight-yellow_background"><code>studentName</code></mark><mark class="highlight-yellow_background">. So, the parameter is shadowing the (shadowed) global variable. </mark></p><p id="edbedd4a-e096-4e6c-9238-707888e4b90e" class="">When you choose to shadow a variable from an outer scope, one direct impact is that from that scope inward/downward (through any nested scopes) <mark class="highlight-yellow_background">it&#x27;s now impossible for any marble to be colored as the shadowed variable—(RED(1), in this case). In other words, any </mark><mark class="highlight-yellow_background"><code>studentName</code></mark><mark class="highlight-yellow_background"> identifier reference will correspond to that parameter variable, never the global </mark><mark class="highlight-yellow_background"><code>studentName</code></mark><mark class="highlight-yellow_background"> variable. It&#x27;s lexically impossible to reference the global </mark><mark class="highlight-yellow_background"><code>studentName</code></mark><mark class="highlight-yellow_background"> anywhere inside of the </mark><mark class="highlight-yellow_background"><code>printStudent(..)</code></mark><mark class="highlight-yellow_background"> function (or from any nested scopes).</mark></p><h3 id="035254db-41d2-4c03-aa70-aad44aadf761" class="">Global Unshadowing Trick - not a good practice </h3><pre id="0621ac51-b7e0-4cc3-9647-70458c0649a5" class="code code-wrap"><code>var studentName = &quot;Suzy&quot;;

function printStudent(studentName) {
    console.log(studentName);
    console.log(window.studentName);
}

printStudent(&quot;Frank&quot;);
// &quot;Frank&quot;
// &quot;Suzy&quot;</code></pre><p id="45de437f-d3e5-4cfc-aaf0-57941b95e9bd" class="">The window.studentName is a mirror of the global studentName variable, not a separate snapshot copy. Changes to one are still seen from the other, in either direction. You can think of window.studentName as a getter/setter that accesses the actual studentName variable. As a matter of fact, you can even add a variable to the global scope by creating/setting a property on the global object.</p><p id="fb4d8ca1-65ab-4fe6-bc27-9b1e891b834d" class="">only works for variables declared with <code>var</code> or <code>function</code>.</p><p id="be2ffb54-2ab4-49a1-8f4f-545ca75150b5" class="">
</p><pre id="55f90840-0045-43b6-873c-cc7b85077c96" class="code"><code>var one = 1;
let notOne = 2;
const notTwo = 3;
class notThree {}

console.log(window.one);       // 1
console.log(window.notOne);    // undefined
console.log(window.notTwo);    // undefined
console.log(window.notThree);  // undefined</code></pre><p id="8fc84fba-c096-406c-8350-5d0df462b4fe" class="">Variables (no matter how they&#x27;re declared!) that exist in any other scope than the global scope are completely inaccessible from a scope where they&#x27;ve been shadowed:</p><pre id="f2ab9108-79bc-48aa-8611-83cacefd1c9a" class="code"><code>var special = 42;

function lookingFor(special) {
    // The identifier `special` (parameter) in this
    // scope is shadowed inside keepLooking(), and
    // is thus inaccessible from that scope.

    function keepLooking() {
        var special = 3.141592;
        console.log(special);
        console.log(window.special);
    }

    keepLooking();
}

lookingFor(112358132134);
// 3.141592
// 42</code></pre><h3 id="a0f0fb97-c239-4c6b-b5a6-7c12de255160" class="">Copying Is Not Accessing</h3><p id="3c684391-9ecc-48a0-998b-54c53fa05b10" class="block-color-pink_background">Mutating the contents of the object value via a reference copy is not the same thing as lexically accessing the variable itself.</p><pre id="e3dcd257-a90b-4499-a5bc-143ea886e1e5" class="code"><code>var special = 42;

function lookingFor(special) {
    var another = {
        special: special
    };

    function keepLooking() {
        var special = 3.141592;
        console.log(special);
        console.log(another.special);  // Ooo, tricky!
        console.log(window.special);
    }

    keepLooking();
}

lookingFor(112358132134);
// 3.141592
// 112358132134
// 42</code></pre><p id="21bef53e-b6ef-407f-8d08-86b1941f373d" class="">Oh! So does this <code>another</code> object technique disprove my claim that the <code>special</code> parameter is &quot;completely inaccessible&quot; from inside <code>keepLooking()</code>? No, the claim is still correct.</p><p id="65a653f4-c185-4abe-8616-2c2c10a7a764" class=""><code>special: special</code> is copying the value of the <code>special</code> parameter variable into another container (a property of the same name). Of course, if you put a value in another container, shadowing no longer applies (unless <code>another</code> was shadowed, too!). But that doesn&#x27;t mean we&#x27;re accessing the parameter <code>special</code>; it means we&#x27;re accessing the copy of the value it had at that moment, by way of <em>another</em> container (object property). We cannot reassign the BLUE(2) <code>special</code> parameter to a different value from inside <code>keepLooking()</code>.</p><p id="56a601d0-5a00-4e90-8516-ad7d5c11ba31" class="">Another &quot;But...!?&quot; you may be about to raise: what if I&#x27;d used objects or arrays as the values instead of the numbers (<code>112358132134</code>, etc.)? Would us having references to objects instead of copies of primitive values &quot;fix&quot; the inaccessibility?</p><p id="ab123a09-66da-4662-932b-01be8485d6d9" class="">No. Mutating the contents of the object value via a reference copy is <strong>not</strong> the same thing as lexically accessing the variable itself. We still can&#x27;t reassign the BLUE(2) <code>special</code> parameter.</p><h3 id="5ee1f1e5-2949-47fb-8c14-32706f86ca15" class="">Illegal Shadowing</h3><p id="5fac3407-c0b1-4c89-94f9-c8d6ea066af4" class="">Not all combinations of declaration shadowing are allowed. <code>let</code> can shadow <code>var</code>, but <code>var</code> cannot shadow <code>let</code>:</p><pre id="1cd11881-8f83-4cd7-aa8a-cdff6bab6fad" class="code"><code>function something() {
    var special = &quot;JavaScript&quot;;

    {
        let special = 42;   // totally fine shadowing

        // ..
    }
}

function another() {
    // ..

    {
        let special = &quot;JavaScript&quot;;

        {
            var special = &quot;JavaScript&quot;;
            // ^^^ Syntax Error

            // ..
        }
    }
}</code></pre><p id="76c930df-5987-46f4-8668-2a25039c7334" class="">
</p><p id="75ba7adb-1fa9-4679-8f1f-b472d103a37d" class="">The real reason it&#x27;s raised as a <code>SyntaxError</code> is because the <mark class="highlight-yellow_background"><code>var</code></mark><mark class="highlight-yellow_background"> is basically trying to &quot;cross the boundary&quot; of (or hop over) the </mark><mark class="highlight-yellow_background"><code>let</code></mark><mark class="highlight-yellow_background"> declaration of the same name, which is not allowed.</mark></p><p id="89b4d6e5-7b29-4e74-be8d-fb406f5ffb9f" class="">That boundary-crossing prohibition effectively stops at each function boundary, so this variant raises no exception:</p><pre id="3494fb89-ad2b-42dc-83ab-db1b989a52b8" class="code"><code>function another() {
    // ..

    {
        let special = &quot;JavaScript&quot;;

        ajax(&quot;https://some.url&quot;,function callback(){
            // totally fine shadowing
            var special = &quot;JavaScript&quot;;

            // ..
        });
    }
}</code></pre><p id="b366e1b9-591a-4cce-a2f9-09e0ae333be1" class="">Summary: <code>let</code> (in an inner scope) can always shadow an outer scope&#x27;s <code>var</code>. <code>var</code> (in an inner scope) can only shadow an outer scope&#x27;s <code>let</code> if there is a function boundary in between.</p><p id="6bd1acc0-122f-4b95-88a8-19ef54019494" class="">Function Name Scope</p><p id="b979d70f-ca77-4041-a2dd-fe3706624009" class="">As you&#x27;ve seen by now, a <code>function</code> declaration looks like this:</p><pre id="b7e5e433-79cc-4da6-a21c-f2276dc5258b" class="code"><code>function askQuestion() {
    // ..
}</code></pre><p id="2f0ce266-5f08-4df3-b4fc-848d05f7377e" class="">And as discussed in Chapters 1 and 2, such a <code>function</code> declaration will create an identifier in the enclosing scope (in this case, the global scope) named <code>askQuestion</code>.</p><p id="4aed22e7-2b28-407c-8093-84c0aa77f2b6" class="">What about this program?</p><pre id="69f50fae-e623-43bd-aa2e-93302a3c3bd9" class="code"><code>var askQuestion = function(){
    // ..
};</code></pre><p id="dc5b8653-7f6b-4533-b5ba-c8fca82933b7" class="">The same is true for the variable <code>askQuestion</code> being created. But since it&#x27;s a <code>function</code> expression—a function definition used as value instead of a standalone declaration—the function itself will not &quot;hoist&quot; (see Chapter 5).</p><p id="a1d0b154-bfb6-4ae9-a3ef-cfc625923afb" class="">One major difference between <code>function</code> declarations and <code>function</code> expressions is what happens to the name identifier of the function. Consider a named <code>function</code> expression:</p><pre id="5d945cc3-360a-4d7a-9cb7-19934f1f4ea5" class="code"><code>var askQuestion = function ofTheTeacher(){
    // ..
};</code></pre><p id="493bd212-396a-4eb2-88f7-a9a5cd004a11" class="">We know <code>askQuestion</code> ends up in the outer scope. But what about the <code>ofTheTeacher</code> identifier? For formal <code>function</code> declarations, the name identifier ends up in the outer/enclosing scope, so it may be reasonable to assume that&#x27;s the case here. But <code>ofTheTeacher</code> is declared as an identifier <strong>inside the function itself</strong>:</p><pre id="c848810e-44dc-4597-9f54-5cfd2ed63a0c" class="code"><code>var askQuestion = function ofTheTeacher() {
    console.log(ofTheTeacher);
};

askQuestion();
// function ofTheTeacher()...

console.log(ofTheTeacher);
// ReferenceError: ofTheTeacher is not defined
</code></pre><p id="bd4fb2b4-e7e9-4b12-921d-aa48e0994c42" class="">Actually, ofTheTeacher is not exactly in the scope of the function. Appendix A, &quot;Implied Scopes&quot; will explain further.
Not only is <code>ofTheTeacher</code> declared inside the function rather than outside, but it&#x27;s also defined as read-only:</p><pre id="fca34122-e044-4388-b758-7197f017b977" class="code"><code>var askQuestion = function ofTheTeacher() {
    &quot;use strict&quot;;
    ofTheTeacher = 42;   // TypeError

    //..
};

askQuestion();
// TypeError</code></pre><p id="a2431f5f-2f18-4140-af73-c8a231eca2d2" class="">Because we used strict-mode, the assignment failure is reported as a <code>TypeError</code>; in non-strict-mode, such an assignment fails silently with no exception.</p><p id="23f4d47f-c685-47d8-bfb5-02399a6fd6e0" class="">What about when a <code>function</code> expression has no name identifier?</p><pre id="0ede4b04-8fe7-4dde-9e42-ba3e80df24ec" class="code"><code>var askQuestion = function(){
   // ..
};</code></pre><p id="05aed8e8-86df-4084-a1f9-7cf8ca86bd99" class="">A <code>function</code> expression with a name identifier is referred to as a &quot;named function expression,&quot; but one without a name identifier is referred to as an &quot;anonymous function expression.&quot; Anonymous function expressions clearly have no name identifier that affects either scope.</p><h3 id="6fb22866-eb9e-4ab4-9070-1b4951addfa3" class="">Arrow functions</h3><p id="02bd77a1-851c-44ba-8f72-a2ee13004836" class="">
</p><p id="c109cc27-b57a-46c2-b37a-3862b9201246" class="">ES6 added an additional <code>function</code> expression form to the language, called &quot;arrow functions&quot;:</p><pre id="3c820ca5-f5eb-457c-98c6-9591e857bef5" class="code"><code>var askQuestion = () =&gt; {
    // ..
};</code></pre><p id="af3ce9f3-6b4e-4278-9675-3f3dab2818a5" class="">The <code>=&gt;</code> arrow function doesn&#x27;t require the word <code>function</code> to define it. Also, the <code>( .. )</code> around the parameter list is optional in some simple cases. Likewise, the <code>{ .. }</code> around the function body is optional in some cases. And when the <code>{ .. }</code> are omitted, a return value is sent out without using a <code>return</code> keyword.</p><p id="66fa7b0b-dcbc-42b2-a5d6-14a9ed91e098" class=""><mark class="highlight-yellow_background">Arrow functions are lexically anonymous, meaning they have no directly related identifier that references the function. The assignment to </mark><mark class="highlight-yellow_background"><code>askQuestion</code></mark><mark class="highlight-yellow_background"> creates an inferred name of &quot;askQuestion&quot;, but that&#x27;s </mark><mark class="highlight-yellow_background"><strong>not the same thing as being non-anonymous</strong></mark><mark class="highlight-yellow_background">:</mark></p><pre id="d7b488d6-7d48-4145-8ee5-3c3dcf12edd9" class="code"><code>var askQuestion = () =&gt; {
    // ..
};

askQuestion.name;   // askQuestion</code></pre><p id="58eec6b1-f8d3-4624-9004-0d80b8998a1f" class="">Arrow functions achieve their syntactic brevity at the expense of having to mentally juggle a bunch of variations for different forms/conditions. Just a few, for example:</p><pre id="8f277f0b-64d0-48a2-aa63-dd9108d24451" class="code"><code>() =&gt; 42;

id =&gt; id.toUpperCase();

(id,name) =&gt; ({ id, name });

(...args) =&gt; {
    return args[args.length - 1];
};</code></pre><p id="a3bb652b-f0c0-4d81-aaa9-e49a9b8d2467" class="">The real reason I bring up arrow functions is because of the common but incorrect claim that arrow functions somehow behave differently with respect to lexical scope from standard <code>function</code> functions.</p><p id="3656f5fc-7c8e-4563-bb05-5569e557e5f1" class="">This is incorrect.</p><p id="f7d22ab0-5588-4998-9446-7446817ab961" class="">Other than being anonymous (and having no declarative form), <code>=&gt;</code> arrow functions have the same lexical scope rules as <code>function</code> functions do. An arrow function, with or without <code>{ .. }</code> around its body, still creates a separate, inner nested bucket of scope. Variable declarations inside this nested scope bucket behave the same as in a <code>function</code> scope.</p><h1 id="20086e8c-8f31-47d3-8aaf-275b8b498ef0" class="">Chapter 2.4 Around the Global Scope</h1><h3 id="11ac35fd-0de5-4929-bdeb-6eeb87aa9cce" class="">Why Global Scope?</h3><p id="6cc8837e-308b-4880-9af4-61fbb90f2a61" class="">How do separate js files get stitched together</p><ol type="1" id="dd609c42-59c3-4947-873c-07cac7ff0b2e" class="numbered-list" start="1"><li>if you&#x27;re directly using ES modules (not transpiling them into some other module-bundle format), these files are loaded individually by the JS environment. Each module then <code>import</code>s references to whichever other modules it needs to access. The separate module files cooperate with each other exclusively through these shared imports, without needing any shared outer scope.</li></ol><ol type="1" id="81fa4eea-d70e-4cdc-b86d-34df6e93ac6e" class="numbered-list" start="2"><li>Second, if you&#x27;re using a bundler in your build process, all the files are typically concatenated together before delivery to the browser and JS engine, which then only processes one big file. Even with all the pieces of the application co-located in a single file, some mechanism is necessary for each piece to register a name to be referred to by other pieces, as well as some facility for that access to occur.</li></ol><ol type="1" id="3d7d652b-9798-439f-81e8-57413a50f195" class="numbered-list" start="3"><li>And finally, the third way: whether a bundler tool is used for an application, or whether the (non-ES module) files are simply loaded in the browser individually (via <code>&lt;script&gt;</code> tags or other dynamic JS resource loading), if there is no single surrounding scope encompassing all these pieces, the <strong>global scope</strong> is the only way for them to cooperate with each other:</li></ol><p id="a7f8cfce-6712-424e-ac8b-b5b082f24fd2" class="">In addition to (potentially) accounting for where an application&#x27;s code resides during runtime, and how each piece is able to access the other pieces to cooperate, the global scope is also where:</p><ul id="05713632-85c8-4909-98ef-bc4045305bdf" class="bulleted-list"><li style="list-style-type:disc">JS exposes its built-ins:<ul id="58f02a3b-fea1-4619-a811-a2658038bbf1" class="bulleted-list"><li style="list-style-type:circle">primitives: <code>undefined</code>, <code>null</code>, <code>Infinity</code>, <code>NaN</code></li></ul><ul id="6e94b361-9f2a-45db-b07f-c3d54696fe20" class="bulleted-list"><li style="list-style-type:circle">natives: <code>Date()</code>, <code>Object()</code>, <code>String()</code>, etc.</li></ul><ul id="294833f1-2823-4d61-92bc-c8d41facb81b" class="bulleted-list"><li style="list-style-type:circle">global functions: <code>eval()</code>, <code>parseInt()</code>, etc.</li></ul><ul id="157af19d-6797-4bd1-93a1-c32e50a532c9" class="bulleted-list"><li style="list-style-type:circle">namespaces: <code>Math</code>, <code>Atomics</code>, <code>JSON</code></li></ul><ul id="104dce1a-b36c-4e2e-9f2a-be1f86da5423" class="bulleted-list"><li style="list-style-type:circle">friends of JS: <code>Intl</code>, <code>WebAssembly</code></li></ul></li></ul><ul id="ab15afef-db14-4c53-a608-ffdf73624ca0" class="bulleted-list"><li style="list-style-type:disc">The environment hosting the JS engine exposes its own built-ins:<ul id="dad38a7f-a4ce-4527-88b7-f7791777df5b" class="bulleted-list"><li style="list-style-type:circle"><code>console</code> (and its methods)</li></ul><ul id="5722da9d-9d3e-4bec-8f95-fdf0bc8c9bdb" class="bulleted-list"><li style="list-style-type:circle">the DOM (<code>window</code>, <code>document</code>, etc)</li></ul><ul id="d4b607f3-18aa-4ef6-a1c6-5ccc06dcd277" class="bulleted-list"><li style="list-style-type:circle">timers (<code>setTimeout(..)</code>, etc)</li></ul><ul id="fc6d61ab-c774-4aed-a29f-3a1f40cb7a6c" class="bulleted-list"><li style="list-style-type:circle">web platform APIs: <code>navigator</code>, <code>history</code>, geolocation, WebRTC, etc.</li></ul></li></ul><p id="857c5319-0c7d-426e-abd5-71dbdaf99b9e" class="">These are just some of the many <em>globals</em> your programs will interact with.</p><h3 id="fdbf98e1-f82a-41c0-95f5-7d23a2ecbeda" class="">Where Exactly is this Global Scope?</h3><h3 id="8aae39f4-5da2-4e18-9f69-c84dbcf5c4b8" class="">Browser &quot;Window&quot;</h3><pre id="d0d15c5e-4b68-4a19-9920-e88d75253312" class="code"><code>var studentName = &quot;Kyle&quot;;

function hello() {
    console.log(`Hello, ${ window.studentName }!`);
}

window.hello();
// Hello, Kyle!</code></pre><p id="00340c0b-6d3f-43af-9350-ecf6c8a75a1f" class="">That&#x27;s the default behavior one would expect from a reading of the JS specification: the outer scope <em>is</em> the global scope and <code>studentName</code> is legitimately created as global variable.</p><h3 id="2c7588e6-a9ce-4d49-afe4-db89a088c4ce" class="">Globals Shadowing Globals</h3><p id="766388d0-be3d-4cf5-867f-0154cbdb2b81" class="">An unusual consequence of the difference between a global variable and a global property of the same name is that, within just the global scope itself, a global object property can be shadowed by a global variable:</p><pre id="14d7bd87-c776-4a29-8f6d-fe56b1378c01" class="code"><code>window.something = 42;

let something = &quot;Kyle&quot;;

console.log(something);
// Kyle

console.log(window.something);
// 42</code></pre><p id="59d05ada-6460-4f48-9a5c-e396dbb12b83" class="">The <code>let</code> declaration adds a <code>something</code> global variable but not a global object property (see Chapter 3). The effect then is that the <code>something</code> lexical identifier shadows the <code>something</code> global object property.</p><p id="f2fae688-751c-402b-95dc-09e15668b193" class="">It&#x27;s almost certainly a bad idea to create a divergence between the global object and the global scope. Readers of your code will almost certainly be tripped up.</p><p id="177270f4-eba0-4523-a22d-77187f4964cf" class="">A simple way to avoid this gotcha with global declarations: always use <code>var</code> for globals. Reserve <code>let</code> and <code>const</code> for block scopes (see &quot;Scoping with Blocks&quot; in Chapter 6).</p><h3 id="1c3e87f8-bf35-4ba0-9a64-8e1334a79b7e" class="">DOM Globals</h3><pre id="3aa1d767-174d-4128-b70e-661730c739b5" class="code code-wrap"><code>&lt;ul id=&quot;my-todo-list&quot;&gt;
   &lt;li id=&quot;first&quot;&gt;Write a book&lt;/li&gt;
   ..
&lt;/ul&gt;
</code></pre><p id="6f8c2fa4-59b3-4d91-be2b-3c116f516827" class="">And the JS for that page could include:</p><pre id="d072db65-2bcf-4c3c-8c25-512da8391c04" class="code"><code>first;
// &lt;li id=&quot;first&quot;&gt;..&lt;/li&gt;

window[&quot;my-todo-list&quot;];
// &lt;ul id=&quot;my-todo-list&quot;&gt;..&lt;/ul&gt;</code></pre><p id="48b3fdbb-b43a-4764-9725-140728bef4df" class="block-color-yellow_background">If the <code>id</code> value is a valid lexical name (like <code>first</code>), the lexical variable is created. If not, the only way to access that global is through the global object (<code>window[..]</code>).</p><p id="a8ee3d50-aa1e-4808-9ec3-4b724e290471" class="">The auto-registration of all <code>id</code>-bearing DOM elements as global variables is an old legacy browser behavior that nevertheless must remain because so many old sites still rely on it. My advice is never to use these global variables, even though they will always be silently created.</p><h3 id="a2f2b392-887e-4dda-8cf5-f31dc2362583" class="">What&#x27;s in a (Window) Name?</h3><pre id="f9706cc3-2604-44f8-8f5c-9b129ad132ff" class="code"><code>var name = 42;

console.log(name, typeof name);
// &quot;42&quot; string</code></pre><p id="ef3327ab-e349-4b9d-9b0f-88c944bc94e1" class=""><code>window.name</code> is a pre-defined &quot;global&quot; in a browser context; it&#x27;s a property on the global object, so it seems like a normal global variable (yet it&#x27;s anything but &quot;normal&quot;).</p><p id="dc1d731a-2346-497d-9d29-372b1c992739" class="">We used <code>var</code> for our declaration, which <strong>does not</strong> shadow the pre-defined <code>name</code> global property. That means, effectively, the <code>var</code> declaration is ignored, since there&#x27;s already a global scope object property of that name. As we discussed earlier, had we used <code>let name</code>, we would have shadowed <code>window.name</code> with a separate global <code>name</code> variable.</p><p id="14a27e9b-8f17-45fd-ba2a-5339824d5da4" class=""><mark class="highlight-yellow_background">But the truly surprising behavior is that even though we assigned the number </mark><mark class="highlight-yellow_background"><code>42</code></mark><mark class="highlight-yellow_background"> to </mark><mark class="highlight-yellow_background"><code>name</code></mark><mark class="highlight-yellow_background"> (and thus </mark><mark class="highlight-yellow_background"><code>window.name</code></mark><mark class="highlight-yellow_background">), when we then retrieve its value, it&#x27;s a string </mark><mark class="highlight-yellow_background"><code>&quot;42&quot;</code></mark><mark class="highlight-yellow_background">! In this case, the weirdness is because </mark><mark class="highlight-yellow_background"><code>name</code></mark><mark class="highlight-yellow_background"> is actually a pre-defined getter/setter on the </mark><mark class="highlight-yellow_background"><code>window</code></mark><mark class="highlight-yellow_background"> object, which insists on its value being a string value. Yikes!</mark></p><p id="18121df3-f612-484c-b7e8-b1da697d6dca" class="">With the exception of some rare corner cases like DOM element ID&#x27;s and <code>window.name</code>, JS running as a standalone file in a browser page has some of the most <em>pure</em> global scope behavior we will encounter.</p><h3 id="bfcebdcb-5c9b-4df9-91c4-9f6a014ee8cd" class="">Web Workers</h3><p id="82440618-a4d0-4d1d-b18a-f486e1185ece" class="">Web Workers are a web platform extension on top of browser-JS behavior, which allows a JS file to run in a completely separate thread (operating system wise) from the thread that&#x27;s running the main JS program.</p><p id="5499227b-5716-42f3-a14a-00c5d070fdc6" class="">Since these Web Worker programs run on a separate thread, they&#x27;re restricted in their communications with the main application thread, to avoid/limit race conditions and other complications. <mark class="highlight-yellow_background">Web Worker code does not have access to the DOM,</mark> for example. Some web APIs are, however, made available to the worker, such as <code>navigator</code>.</p><p id="0434ecf8-6eec-48d9-aaf6-1e7147fc58e0" class="">In a Web Worker, the global object reference is typically made using <code>self</code>:</p><pre id="8c6bf63d-2147-474a-9260-3e7bdf4939b6" class="code"><code>var studentName = &quot;Kyle&quot;;
let studentID = 42;

function hello() {
    console.log(`Hello, ${ self.studentName }!`);
}

self.hello();
// Hello, Kyle!

self.studentID;
// undefined</code></pre><p id="d62ce2c1-de4d-4692-b65e-d41c6b39cd17" class="">Just as with main JS programs, <code>var</code> and <code>function</code> declarations create mirrored properties on the global object (aka, <code>self</code>), where other declarations (<code>let</code>, etc) do not.</p><h3 id="ec35cad5-2885-4b62-9757-97816e880fd4" class="">ES Modules(ESM)</h3><p id="f2d81ba0-64b4-4639-860f-df766bf1116e" class="">Recall this code snippet from earlier (which we&#x27;ll adjust to ESM format by using the <code>export</code> keyword):</p><pre id="6ebf2ab1-7676-4222-b254-3c52a795ad79" class="code"><code>var studentName = &quot;Kyle&quot;;

function hello() {
    console.log(`Hello, ${ studentName }!`);
}

hello();
// Hello, Kyle!

export hello;</code></pre><p id="c2658523-7f46-4a01-ae9c-f4efc417b07e" class="">If that code is in a file that&#x27;s loaded as an ES module, it will still run exactly the same. However, the observable effects, from the overall application perspective, will be different.</p><p id="49da968f-347d-4a64-80c8-0de2091deecc" class="">Despite being declared at the top level of the (module) file, in the outermost obvious scope, <code>studentName</code> and <code>hello</code> are not global variables. Instead, they are module-wide, or if you prefer, &quot;module-global.&quot;</p><p id="0e1ef690-6faa-402d-b5c7-aeaac1264350" class="">ESM encourages a minimization of reliance on the global scope, where you import whatever modules you may need for the current module to operate. As such, you less often see usage of the global scope or its global object.</p><h3 id="6f2c832d-3cba-43cc-912a-7e1b39bf4666" class="">Node</h3><p id="7a307aea-299b-492d-9b40-d7c032c04ef3" class="">Node treats every single .js file that it loads, including the main one you start the Node process with, as a module (ES module or CommonJS module, see Chapter 8). The practical effect is that the top level of your Node programs is never actually the global scope, the way it is when loading a non-module file in the browser.</p><pre id="fcc32326-b866-4cda-bfda-83681ec1d7ce" class="code"><code>var studentName = &quot;Kyle&quot;;

function hello() {
    console.log(`Hello, ${ studentName }!`);
}

hello();
// Hello, Kyle!

module.exports.hello = hello;</code></pre><p id="757ab39a-1954-4587-bb5a-fb5d64b736e6" class="">Before processing, Node effectively wraps such code in a function, so that the <code>var</code> and <code>function</code> declarations are contained in that wrapping function&#x27;s scope, <strong>not</strong> treated as global variables.</p><p id="89f90f1a-1913-4151-a05c-b8efbe1d5b89" class="">Envision the preceding code as being seen by Node as this (illustrative, not actual):</p><pre id="6b941013-80da-4faa-b030-7572cce9e977" class="code"><code>function Module(module,require,__dirname,...) {
    var studentName = &quot;Kyle&quot;;

    function hello() {
        console.log(`Hello, ${ studentName }!`);
    }

    hello();
    // Hello, Kyle!

    module.exports.hello = hello;
}</code></pre><p id="6e1a3110-8da0-4729-9f0c-df9d75c78486" class="">Node then essentially invokes the added <code>Module(..)</code> function to run your module. You can clearly see here why <code>studentName</code> and <code>hello</code> identifiers are not global, but rather declared in the module scope.</p><p id="bb8dff83-6063-4b58-bdda-76124a036bdb" class="">So how do you define actual global variables in Node? The only way to do so is to add properties to another of Node&#x27;s automatically provided &quot;globals,&quot; which is ironically called <code>global</code>. <code>global</code> is a reference to the real global scope object, somewhat like using <code>window</code> in a browser JS environment.</p><p id="6f1282cd-ba72-4142-8f7a-268526142f18" class="">Consider:</p><pre id="583283b8-a542-422c-b8b4-fd67416a9c3e" class="code"><code>global.studentName = &quot;Kyle&quot;;

function hello() {
    console.log(`Hello, ${ studentName }!`);
}

hello();
// Hello, Kyle!

module.exports.hello = hello;</code></pre><p id="a777102e-b066-4086-b52b-e8c2e81fff73" class="">Here we add <code>studentName</code> as a property on the <code>global</code> object, and then in the <code>console.log(..)</code> statement we&#x27;re able to access <code>studentName</code> as a normal global variable.</p><p id="c9690e83-55a2-4f44-9980-5c9189fc198d" class="">Remember, the identifier <code>global</code> is not defined by JS; it&#x27;s specifically defined by Node.</p><h3 id="6c7bb46b-86df-40b9-b5ba-d7680e931d26" class="">Global This</h3><p id="f0b32a2c-18f1-492e-814e-97ad26633e74" class="">Reviewing the JS environments we&#x27;ve looked at so far, a program may or may not:</p><ul id="26cefdd4-67e0-42c1-a105-5f5d65aa8416" class="bulleted-list"><li style="list-style-type:disc">Declare a global variable in the top-level scope with <code>var</code> or <code>function</code> declarations—or <code>let</code>, <code>const</code>, and <code>class</code>.</li></ul><ul id="cccefa63-7c6c-41e5-90a5-1cd62c2b25dd" class="bulleted-list"><li style="list-style-type:disc">Also add global variables declarations as properties of the global scope object if <code>var</code> or <code>function</code> are used for the declaration.</li></ul><ul id="f23865d6-aa90-40e8-88b2-e46ea5300c61" class="bulleted-list"><li style="list-style-type:disc">Refer to the global scope object (for adding or retrieving global variables, as properties) with <code>window</code>, <code>self</code>, or <code>global</code>.</li></ul><p id="66317812-e787-4bff-a031-b506e17d2449" class="">I think it&#x27;s fair to say that global scope access and behavior is more complicated than most developers assume, as the preceding sections have illustrated. But the complexity is never more obvious than in trying to nail down a universally applicable reference to the global scope object.</p><p id="ebbc2e1b-b1a3-4f0a-afc2-4c9f49cb8077" class="">Yet another &quot;trick&quot; for obtaining a reference to the global scope object looks like:</p><pre id="3b54dd9b-9eb7-4708-a134-aef438c5705a" class="code"><code>const theGlobalScopeObject =
    (new Function(&quot;return this&quot;))();</code></pre><p id="cc2a482d-1859-4d65-ba50-23259920cae7" class="">A function can be dynamically constructed from code stored in a string value with the Function() constructor, similar to eval(..) (see &quot;Cheating: Runtime Scope Modifications&quot; in Chapter 1). Such a function will automatically be run in non-strict-mode (for legacy reasons) when invoked with the normal () function invocation as shown; its this will point at the global object. See the third book in the series, Objects &amp; Classes, for more information on determining this bindings.</p><p id="899d7329-5223-4c1c-8991-b8f78eb46525" class="">So, we have <code>window</code>, <code>self</code>, <code>global</code>, and this ugly <code>new Function(..)</code> trick. That&#x27;s a lot of different ways to try to get at this global object. Each has its pros and cons.</p><p id="40b94bb4-3b7f-4bfb-82a9-29918a56aa09" class="">Why not introduce yet another!?!?</p><p id="d3a63858-4602-421f-8f81-8e15b3243321" class="">As of ES2020, JS has finally defined a standardized reference to the global scope object, called <code>globalThis</code>. So, subject to the recency of the JS engines your code runs in, you can use <code>globalThis</code> in place of any of those other approaches.</p><p id="f3d9fcee-0a76-4c5e-963b-86946bffb463" class="">We could even attempt to define a cross-environment polyfill that&#x27;s safer across pre-<code>globalThis</code> JS environments, such as:</p><pre id="96c5d367-75db-4256-a5a2-a71843dc9e84" class="code"><code>const theGlobalScopeObject =
    (typeof globalThis != &quot;undefined&quot;) ? globalThis :
    (typeof global != &quot;undefined&quot;) ? global :
    (typeof window != &quot;undefined&quot;) ? window :
    (typeof self != &quot;undefined&quot;) ? self :
    (new Function(&quot;return this&quot;))();</code></pre><p id="b28b64fc-7c92-4dc4-aa42-793b79e56f4f" class="">Phew! That&#x27;s certainly not ideal, but it works if you find yourself needing a reliable global scope reference.</p><p id="2c4b5745-7f7d-41dd-8865-ef7767932839" class="">(The proposed name <code>globalThis</code> was fairly controversial while the feature was being added to JS. Specifically, I and many others felt the &quot;this&quot; reference in its name was misleading, since the reason you reference this object is to access to the global scope, never to access some sort of global/default <code>this</code> binding. There were many other names considered, but for a variety of reasons ruled out. Unfortunately, the name chosen ended up as a last resort. If you plan to interact with the global scope object in your programs, to reduce confusion, I strongly recommend choosing a better name, such as (the laughably long but accurate!) <code>theGlobalScopeObject</code> used here.)</p><h1 id="f3806081-7f23-4fd6-ad99-a5ee1ca1c309" class="">Chapter 2.5: The (Not So) Secret Lifecycle of Variables</h1><h3 id="8c1f3778-cc17-48f6-9472-4a09151b04e8" class="">When Can I Use a Variable?</h3><p id="0bb9a61c-c97d-4d4c-ad21-b42b1b79ea72" class="">all identifiers are registered to their respective scopes during compile time. Moreover, every identifier is <em>created</em> at the beginning of the scope it belongs to, <strong>every time that scope is entered</strong>.</p><p id="687a081b-f851-42a8-a194-d547201d129d" class="">The term most commonly used for a variable being visible from the beginning of its enclosing scope, even though its declaration may appear further down in the scope, is called <strong>hoisting</strong>.</p><p id="7c0afdd6-9bdf-4767-b686-d2c9a1dee3bc" class="">f<em>unction hoisting:</em><div class="indented"><p id="2133634c-97f2-4293-ad32-af1004e500cb" class=""><mark class="highlight-yellow_background">When a </mark><mark class="highlight-yellow_background"><code>function</code></mark><mark class="highlight-yellow_background"> declaration&#x27;s name identifier is registered at the top of its scope, it&#x27;s additionally auto-initialized to that function&#x27;s reference. </mark>That&#x27;s why the function can be called throughout the entire scope!</p></div></p><p id="1b8b3eb6-1c09-49c9-9c68-f860ae187e00" class="">One key detail is that both <em>function hoisting</em> and <code>var</code>-flavored <em>variable hoisting</em> attach their name identifiers to the nearest enclosing <mark class="highlight-yellow_background"><strong>function scope</strong></mark> (or, if none, the global scope), not a block scope.</p><p id="5e0acfea-fa47-479c-ae59-b48aa4e60593" class="">Declarations with <strong>let</strong> and <strong>const</strong> still hoist (see the TDZ discussion later in this chapter). But these two declaration forms attach to their enclosing block rather than just an enclosing function as with var and function declarations. See &quot;Scoping with Blocks&quot; in Chapter 6 for more information.</p><h3 id="410518c9-f71e-45ab-aa2d-6201029539b9" class="">Hoisting: Declaration vs. Expression</h3><p id="26619273-6c7e-4184-b0d3-afeda11da8d4" class=""><em>Function hoisting</em> only applies to formal <code>function</code> declarations (specifically those which appear outside of blocks—see &quot;FiB&quot; in Chapter 6), not to <code>function</code> expression assignments. Consider:</p><pre id="d5353034-9883-459d-8674-a01cb54da79b" class="code"><code>greeting();
// TypeError

var greeting = function greeting() {
    console.log(&quot;Hello!&quot;);
};</code></pre><p id="b4de1086-b7d4-4547-99dd-3fc9452d7da3" class="">A TypeError means we&#x27;re trying to do something with a value that is not allowed.</p><p id="82a1cb72-cee9-42b1-a298-87cd8aff95fb" class="">Notice that the error is <strong>not</strong> a <code>ReferenceError</code>. JS isn&#x27;t telling us that it couldn&#x27;t find <code>greeting</code> as an identifier in the scope. It&#x27;s telling us that <code>greeting</code> was found but doesn&#x27;t hold a function reference at that moment. Only functions can be invoked, so attempting to invoke some non-function value results in an error.</p><p id="40ad6acf-80c7-47b1-85e3-96dfda0c46b2" class="">In addition to being hoisted, variables declared with <code>var</code> are also automatically initialized to <code>undefined</code> at the beginning of their scope—again, the nearest enclosing function, or the global. Once initialized, they&#x27;re available to be used (assigned to, retrieved from, etc.) throughout the whole scope.</p><p id="8a519947-fbbc-4e74-bb6f-9c4fc7b3be2d" class="">So on that first line, <code>greeting</code> exists, but it holds only the default <code>undefined</code> value. It&#x27;s not until line 4 that <code>greeting</code> gets assigned the function reference.</p><p id="22156ee7-79fa-4b5c-a433-0d47a1c90fd1" class=""><mark class="highlight-yellow_background">A </mark><mark class="highlight-yellow_background"><code>function</code></mark><mark class="highlight-yellow_background"> declaration is hoisted </mark><mark class="highlight-yellow_background"><strong>and initialized to its function value</strong></mark><mark class="highlight-yellow_background"> (again, called </mark><mark class="highlight-yellow_background"><em>function hoisting</em></mark><mark class="highlight-yellow_background">). A </mark><mark class="highlight-yellow_background"><code>var</code></mark><mark class="highlight-yellow_background"> variable is also hoisted, and then auto-initialized to </mark><mark class="highlight-yellow_background"><code>undefined</code></mark><mark class="highlight-yellow_background">. Any subsequent </mark><mark class="highlight-yellow_background"><code>function</code></mark><mark class="highlight-yellow_background"> expression assignments to that variable don&#x27;t happen until that assignment is processed during runtime execution.</mark></p><p id="83ad9f5c-f6d0-4196-bfca-0e360eba95e4" class="">In both cases, the name of the identifier is hoisted. But the function reference association isn&#x27;t handled at initialization time (beginning of the scope) unless the identifier was created in a formal <code>function</code> declaration.</p><h3 id="2ec8d1b8-de2a-4117-9f11-56735adcb6b2" class="">Variable Hoisting</h3><pre id="fb8afa2f-ddb5-4eef-bb93-ab6e3dabf539" class="code"><code>greeting = &quot;Hello!&quot;;
console.log(greeting);
// Hello!

var greeting = &quot;Howdy!&quot;;</code></pre><p id="99653473-1e6b-410c-8da9-33a358fadc13" class="">Though <code>greeting</code> isn&#x27;t declared until line 5, it&#x27;s available to be assigned to as early as line 1. Why?</p><p id="1e9aec9e-57dc-47e4-b8a3-d5c550663fba" class="">There&#x27;s two necessary parts to the explanation:</p><ul id="306f6d2c-a1f8-466f-ae32-a6241064ff2d" class="bulleted-list"><li style="list-style-type:disc">the identifier is hoisted,</li></ul><ul id="2e7c8519-72a6-43e1-a4d3-6035a63b6365" class="bulleted-list"><li style="list-style-type:disc"><strong>and</strong> it&#x27;s automatically initialized to the value <code>undefined</code> from the top of the scope.</li></ul><p id="39e1463c-4c0b-4626-a155-eeae63997376" class=""><mark class="highlight-yellow_background">hoisting </mark><mark class="highlight-yellow_background"><em>should</em></mark><mark class="highlight-yellow_background"> be used to refer to the </mark><mark class="highlight-yellow_background"><strong>compile-time operation</strong></mark><mark class="highlight-yellow_background"> of generating runtime instructions for the automatic registration of a variable at the beginning of its scope, each time that scope is entered.</mark></p><p id="df0890de-c808-4240-968c-e071d5c0b9a6" class="">That&#x27;s a subtle but important shift, from hoisting as a runtime behavior to its proper place among compile-time tasks.</p><h3 id="85583392-0b29-4126-948a-c90d7469cd9d" class="">Re-declaration</h3><p id="21e19d47-d6fc-4ed4-84bf-9bcfdfbe023b" class="">var</p><p id="fee0b2ef-b82a-4064-aea7-2823500e4c73" class="">Since hoisting is actually about registering a variable at the beginning of a scope, there&#x27;s nothing to be done in the middle of the scope where the original program actually had the second var studentName statement. It&#x27;s just a no-op(eration), a pointless statement.</p><pre id="7fe4e04b-8e9e-4b88-9810-3fe26bc55ee3" class="code"><code>var studentName = &quot;Frank&quot;;
console.log(studentName);
// Frank

var studentName; // this is a no-op
console.log(studentName);   // Frank</code></pre><p id="695dd486-675d-4415-b6bd-b1ce3d6d4b33" class=""><code>var studentName;</code> doesn&#x27;t mean <code>var studentName = undefined;</code>, as most assume. Let&#x27;s prove they&#x27;re different by considering this variation of the program:</p><p id="5d983669-54b6-4ce7-b29e-d4cf6a92049d" class="">let</p><p id="3b977f26-b8fb-4315-ab0d-a40aca6136c4" class="">When Compiler asks Scope Manager about a declaration, if that identifier has already been declared, and if either/both declarations were made with <strong>let</strong>, an error is thrown. The intended signal to the developer is &quot;Stop relying on sloppy re-declaration!&quot;</p><pre id="16f9897b-44f5-4346-b5f0-7f29c86398e3" class="code"><code>let studentName = &quot;Frank&quot;;
let studentName = &quot;Suzy&quot;; //sytax error</code></pre><pre id="9b939cf3-a4ec-41fc-ad55-6fe429e55d80" class="code"><code>let studentName = &quot;Frank&quot;;
var studentName = &quot;Suzy&quot;; //sytax error</code></pre><pre id="a9a31e48-0221-4b39-b185-7da87ef03418" class="code"><code>
var studentName = &quot;Suzy&quot;; 
let studentName = &quot;Frank&quot;; //sytax error</code></pre><h3 id="77e11aaf-672c-484c-adaf-47a862a3e325" class="">Constants</h3><p id="21ae677d-4891-477f-b360-f87aeadfd0a8" class="">The <code>const</code> keyword requires a variable to be initialized, so omitting an assignment from the declaration results in a <code>SyntaxError</code>:</p><pre id="c1b075d2-a28c-452b-8985-41433ee388a4" class="code"><code>const empty;   // SyntaxError</code></pre><p id="318c9257-62ca-41f9-9ac7-b343c3fa5d4a" class=""><code>const</code> declarations create variables that cannot be re-assigned:</p><pre id="078170ae-87f3-40f7-81e7-ca170ca73920" class="code"><code>const studentName = &quot;Frank&quot;;
console.log(studentName);
// Frank

studentName = &quot;Suzy&quot;;   // TypeError</code></pre><p id="152bc159-6dde-4a07-82ea-95a3e8831fac" class="">The error thrown when re-assigning studentName is a<strong> </strong><mark class="highlight-yellow_background"><strong>TypeError</strong></mark><strong>,</strong> not a <mark class="highlight-yellow_background"><strong>SyntaxError</strong></mark>. <mark class="highlight-yellow_background">Syntax errors represent faults in the program that stop it from even starting execution. Type errors represent faults that arise during program execution.</mark> In the preceding snippet, &quot;Frank&quot; is printed out before we process the re-assignment of studentName, which then throws the error.</p><p id="16d7dd6e-b351-44d4-8e1e-3b93a86a355c" class="">const &quot;re-declaration&quot; must be disallowed</p><h3 id="780101eb-351e-41a7-9639-d333f5c93df9" class="">Loops</h3><pre id="be1dfe82-0f12-4e82-a230-844aec0d380f" class="code code-wrap"><code>var keepGoing = true;
while (keepGoing) {
    let value = Math.random();//allowed, no re-declaration.
    if (value &gt; 0.5) {
        keepGoing = false;
    }
}</code></pre><p id="e7a7b7a7-c4ee-4e7d-9246-c94e636479a6" class="">All the rules of scope (including &quot;re-declaration&quot; of <code>let</code>-created variables) are applied <em>per scope instance</em>. In other words, <mark class="highlight-yellow_background">each time a scope is entered during execution, everything resets</mark>.</p><p id="723908d1-6cb7-416e-9f3d-09c71b2327fa" class=""><mark class="highlight-yellow_background">Each loop iteration is its own new scope instance</mark>, and within each scope instance, <code>value</code> is only being declared once. So there&#x27;s no attempted &quot;re-declaration,&quot; and thus no error. </p><pre id="f50b1d33-a2a6-40a5-96a5-e562534fd7e8" class="code"><code>var keepGoing = true;
while (keepGoing) {
    var value = Math.random();
    if (value &gt; 0.5) {
        keepGoing = false;
    }
}</code></pre><p id="0c8ed38b-78ec-42be-98cf-302d4538766d" class="">Is <code>value</code> being &quot;re-declared&quot; here, especially since we know <code>var</code> allows it? No. Because <code>var</code> is not treated as a block-scoping declaration (see Chapter 6), it attaches itself to the global scope. So there&#x27;s just one <code>value</code> variable, in the same scope as <code>keepGoing</code> (global scope, in this case). No &quot;re-declaration&quot; here, either!</p><p id="d5fef9d9-b3e9-43a7-aa2b-32f2bc5cf982" class="">One way to keep this all straight is to remember that <code>var</code>, <code>let</code>, and <code>const</code> keywords are effectively <em>removed</em> from the code by the time it starts to execute. They&#x27;re handled entirely by the compiler.</p><figure id="dcf70470-0316-465b-9707-1509759a8bd4" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2024.png"><img style="width:783px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2024.png"/></a></figure><p id="3e861e4d-7adf-4164-a15a-b75f87decd3b" class="">the i and value variables are both declared exactly once per scope instance. No &quot;re-declaration&quot; here.</p><pre id="78430d68-ac57-4f05-8c33-b0ed983b11b3" class="code"><code>for (const index in students) {
    // this is fine
}

for (const student of students) {
    // this is also fine
}</code></pre><p id="098ef24f-9e82-4f96-a5b4-406f7a812670" class="">But not the general <code>for</code>-loop:</p><pre id="c7edafa4-5044-4665-8ebd-09b299ad4e45" class="code"><code>for (const i = 0; i &lt; 3; i++) {
    // oops, this is going to fail with
    // a Type Error after the first iteration
}</code></pre><pre id="4cd932e0-bb49-4d65-9b85-20c18effc98f" class="code"><code>{
    // a fictional variable for illustration
    const $$i = 0; //this is the problem

    for ( ; $$i &lt; 3; $$i++) {
        // here&#x27;s our actual loop `i`!
        const i = $$i;
        // ..
    }
}</code></pre><p id="5a317f40-e8c0-4d13-9e09-22d9e6c2dfd2" class="">why i can&#x27;t be const:</p><p id="57e8ff06-c96e-43e0-a816-b2e5699a8485" class=""> Our <code>i</code> is indeed just created once inside the loop. That&#x27;s not the problem. The problem is the conceptual <code>$$i</code> that must be incremented each time with the <code>$$i++</code> expression. That&#x27;s <strong>re-assignment</strong> (not &quot;re-declaration&quot;), which isn&#x27;t allowed for constants.</p><h3 id="e75d5e51-650a-434b-87b1-ac84b2725dce" class="">Uninitialized Variables (aka, TDZ)</h3><pre id="da57cae3-eece-4b49-b351-65ce4747f11c" class="code"><code>studentName = &quot;Suzy&quot;;   // let&#x27;s try to initialize it!
// ReferenceError

console.log(studentName);

let studentName;</code></pre><p id="a31d5bc9-e80f-4639-8921-360a8c9a2a13" class="">For <code>let</code>/<code>const</code>, the <strong>only way</strong> to initialize an uninitialized variable is with an assignment attached to a declaration statement. An assignment by itself is insufficient! Consider:</p><pre id="7cf84f34-9215-4807-a905-5dc73f4c920b" class="code"><code>let studentName = &quot;Suzy&quot;;
console.log(studentName);   // Suzy</code></pre><p id="5c71d270-8972-47e4-b9a6-d3cf87af2b2b" class="">Here, we are initializing the <code>studentName</code> (in this case, to <code>&quot;Suzy&quot;</code> instead of <code>undefined</code>) by way of the <code>let</code> declaration statement form that&#x27;s coupled with an assignment.</p><p id="f6cd6a98-0d7e-4a68-9a03-e9f9ee996c0d" class="">Alternatively:</p><pre id="9ffa0c9b-a16c-40e8-8474-e13b4f76b81a" class="code"><code>// ..

let studentName;
// or:
// let studentName = undefined;

// ..

studentName = &quot;Suzy&quot;;

console.log(studentName);
// Suzy</code></pre><ol type="1" id="15b4ac18-461f-4994-877e-ea9434cbe1c2" class="numbered-list" start="1"><li><em>Compiler</em> ends up removing any <code>var</code>/<code>let</code>/<code>const</code> declarators, replacing them with the instructions at the top of each scope to register the appropriate identifiers.</li></ol><ol type="1" id="2e9d11bd-cd8c-44cc-89d5-d2148f8435e5" class="numbered-list" start="2"><li><em>Compiler</em> is also adding an instruction in the middle of the program, at the point where the variable <code>studentName</code> was declared, to handle that declaration&#x27;s auto-initialization. We cannot use the variable at any point prior to that initialization occuring. The same goes for <code>const</code> as it does for <code>let</code>.</li></ol><p id="41b61ccd-69e6-47d8-9f61-7d33107c0eae" class="">TDZ: this <em>period of time</em> from the entering of a scope to where the auto-initialization of the variable occurs is: Temporal Dead Zone (TDZ).</p><figure id="a58c2dc2-af6f-470f-a111-30961d8b6d26" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2025.png"><img style="width:520px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2025.png"/></a></figure><p id="5cbe1de1-3d60-4f41-874a-0924b7c1a8a7" class="">The TDZ is the time window where a variable exists but is still uninitialized, and therefore cannot be accessed in any way. <mark class="highlight-yellow_background">Only the execution of the instructions left by </mark><mark class="highlight-yellow_background"><em>Compiler</em></mark><mark class="highlight-yellow_background"> at the point of the original declaration can do that initialization. After that moment, the TDZ is done, and the variable is free to be used for the rest of the scope.</mark></p><p id="6c704b75-fa36-4e65-af21-f5ae0a4956a3" class="">A <code>var</code> also has technically has a TDZ, but it&#x27;s zero in length and thus unobservable to our programs! Only <code>let</code> and <code>const</code> have an observable TDZ.</p><p id="a9f26480-2096-4a74-8665-a69974812e4c" class="">By the way, &quot;temporal&quot; in TDZ does indeed refer to <mark class="highlight-yellow_background"><em>time</em></mark> not <em>position in code</em>. Consider:</p><pre id="b876a093-0c71-45d9-b505-f03af84f405f" class="code"><code>askQuestion();
// ReferenceError

let studentName = &quot;Suzy&quot;;

function askQuestion() {
    console.log(`${ studentName }, do you know?`);
}</code></pre><p id="64536e38-d096-4983-b68c-4496c7bcc170" class="">Even though positionally the <code>console.log(..)</code> referencing <code>studentName</code> comes <em>after</em> the <code>let studentName</code> declaration, timing wise the <code>askQuestion()</code> function is invoked <em>before</em> the <code>let</code> statement is encountered, while <code>studentName</code> is still in its TDZ! Hence the error.</p><p id="0a584eec-31b5-4716-8166-453225d56d5b" class=""><mark class="highlight-yellow_background">There&#x27;s a common misconception that TDZ means </mark><mark class="highlight-yellow_background"><code>let</code></mark><mark class="highlight-yellow_background"> and </mark><mark class="highlight-yellow_background"><code>const</code></mark><mark class="highlight-yellow_background"> do not hoist. This is an inaccurate, or at least slightly misleading, claim. They definitely hoist.</mark></p><p id="17093cc8-af89-4044-b5d5-d06f6c46a7a9" class="">The actual difference is that <code>let</code>/<code>const</code> declarations do not automatically initialize at the beginning of the scope, the way <code>var</code> does. </p><p id="e20ad08d-09b0-4187-9fda-f1fa8ce18c79" class="">The <em>debate</em> then is if the auto-initialization is <em>part of</em> hoisting, or not? I think <mark class="highlight-yellow_background">auto-registration of a variable at the top of the scope (i.e., what I call &quot;hoisting&quot;) and auto-initialization at the top of the scope (to </mark><mark class="highlight-yellow_background"><code>undefined</code></mark><mark class="highlight-yellow_background">) are distinct operations and shouldn&#x27;t be lumped together under the single term &quot;hoisting.&quot;</mark></p><p id="c7377c34-cf0a-42a2-a80f-7037849b1879" class="">prove that <code>let</code> and <code>const</code> <em>do</em> hoist (auto-register at the top of the scope):</p><pre id="947a422c-e86a-4c6e-9b3d-7e502b9eee4c" class="code"><code>var studentName = &quot;Kyle&quot;;

{
    console.log(studentName);
    // TDZ error because let was hoisted and not initialized

    // ..

    let studentName = &quot;Suzy&quot;;

    console.log(studentName);
    // Suzy
}</code></pre><p id="0ad8fb75-1ee5-4989-9fa0-067637af25af" class="">What&#x27;s going to happen with the first <code>console.log(..)</code> statement? If <code>let studentName</code> didn&#x27;t hoist to the top of the scope, then the first <code>console.log(..)</code> <em>should</em> print <code>&quot;Kyle&quot;</code>, right? At that moment, it would seem, only the outer <code>studentName</code> exists, so that&#x27;s the variable <code>console.log(..)</code> should access and print.</p><p id="73a2eabd-67a8-4864-ac80-a2c7c74f9304" class="">But instead, the first <code>console.log(..)</code> throws a TDZ error, because in fact, the inner scope&#x27;s <code>studentName</code> <strong>was</strong> hoisted (auto-registered at the top of the scope). What <strong>didn&#x27;t</strong> happen (yet!) was the auto-initialization of that inner <code>studentName</code>; it&#x27;s still uninitialized at that moment, hence the TDZ violation!</p><p id="98661bf9-7d6c-4830-ba31-5560f148b3fa" class="">So to summarize, <mark class="highlight-yellow_background">TDZ errors occur because </mark><mark class="highlight-yellow_background"><code>let</code></mark><mark class="highlight-yellow_background">/</mark><mark class="highlight-yellow_background"><code>const</code></mark><mark class="highlight-yellow_background"> declarations </mark><mark class="highlight-yellow_background"><em>do</em></mark><mark class="highlight-yellow_background"> hoist their declarations to the top of their scopes, but unlike </mark><mark class="highlight-yellow_background"><code>var</code></mark><mark class="highlight-yellow_background">, they defer the auto-initialization of their variables until the moment in the code&#x27;s sequencing where the original declaration appeared. This window of time (hint: temporal), whatever its length, is the TDZ.</mark></p><p id="4644169c-cbd7-4b0f-95b2-49322ab36857" class=""><mark class="highlight-yellow_background">always put your </mark><mark class="highlight-yellow_background"><code>let</code></mark><mark class="highlight-yellow_background"> and </mark><mark class="highlight-yellow_background"><code>const</code></mark><mark class="highlight-yellow_background"> declarations at the top of any scope. Shrink the TDZ window to zero (or near zero) length, and then it&#x27;ll be moot.</mark></p><h1 id="bf801265-8d1c-405a-b000-4507e7b35b62" class="">Chapter 2.6: Limiting Scope Exposure</h1><h3 id="53757caa-7997-46a8-9412-1a21a717ed9b" class="">Least Exposure - POLE/POLP</h3><p id="da523f03-8063-4dca-ad3a-1db0ebc45825" class="">POLE: The Principle of Least Exposure  POLP: The Principle of Least Privilege</p><p id="26d328de-4c79-4541-9199-73d3d6847dca" class=""><mark class="highlight-yellow_background">POLP expresses a defensive posture to software architecture</mark>: components of the system should be designed to function with least privilege, least access, least exposure. If each piece is connected with minimum-necessary capabilities, the overall system is stronger from a security standpoint, because a compromise or failure of one piece has a minimized impact on the rest of the system.</p><ul id="3f2b5283-1463-40b0-88c3-c918cdfdcbd7" class="bulleted-list"><li style="list-style-type:disc"><strong>Naming Collisions</strong>: if you use a common and useful variable/function name in two different parts of the program, but the identifier comes from one shared scope (like the global scope), then name collision occurs, and it&#x27;s very likely that bugs will occur as one part uses the variable/function in a way the other part doesn&#x27;t expect.</li></ul><ul id="d05a69df-85e3-44d7-9f53-3301eb875302" class="bulleted-list"><li style="list-style-type:disc"><strong>Unexpected Behavior</strong>: if you expose variables/functions whose usage is otherwise <em>private</em> to a piece of the program, it allows other developers to use them in ways you didn&#x27;t intend, which can violate expected behavior and cause bugs.</li></ul><ul id="eed41742-67c2-4914-aa19-7860f96524b6" class="bulleted-list"><li style="list-style-type:disc"><strong>Unintended Dependency</strong>: if you expose variables/functions unnecessarily, it invites other developers to use and depend on those otherwise <em>private</em> pieces. While that doesn&#x27;t break your program today, it creates a refactoring hazard in the future, because now you cannot as easily refactor that variable or function without potentially breaking other parts of the software that you don&#x27;t control.</li></ul><h3 id="c883975a-cc4a-431b-a159-8b98e0dcf8af" class="">Hiding in Plain (Function) Scope</h3><p id="442e344b-28ac-41f2-95d0-0b44a4ea9a29" class="">How to achive POLE by hiding variable and function declaration in the lowest scope possible?</p><p id="7af8da49-363c-40c6-b8a9-c3b57af3d189" class="">create a middle scope</p><figure id="8c85a906-6a03-4aa0-bd90-1d317ea8818c" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2026.png"><img style="width:809px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2026.png"/></a></figure><p id="912e1c71-dc9b-411c-b039-13f511acc177" class="">what happens to the name identifier from a <code>function</code> expression</p><p id="7ce7d55f-5e69-4652-b996-6a7aa440a08f" class="">Since <code>hideTheCache(..)</code> is defined as a <code>function</code> expression instead of a <code>function</code> declaration, its name is in its own scope—essentially the same scope as <code>cache</code>—rather than in the outer/global scope.</p><p id="783ff80a-3c58-4a89-a8d5-75370c3b5747" class="">That means we can name every single occurrence of such a function expression the exact same name, and never have any collision. More appropriately, we can name each occurrence semantically based on whatever it is we&#x27;re trying to hide, and not worry that whatever name we choose is going to collide with any other <code>function</code> expression scope in the program.</p><p id="28cf9cda-d7a0-43b6-b739-9307156971b5" class="">In fact, we <em>could</em> just leave off the name entirely—thus defining an &quot;anonymous <code>function</code> expression&quot; instead. But Appendix A will discuss the importance of names even for such scope-only functions.</p><h3 id="974568c9-46b6-45f5-8d45-5edd51755c9e" class="">Invoking Function Expressions Immediately</h3><p id="31f96263-6ee5-42d9-aa02-e839f5c54cb4" class=""><mark class="highlight-yellow_background">An IIFE is useful when we want to create a scope to hide variables/functions.</mark> Since it&#x27;s an expression, it can be used in <strong>any</strong> place in a JS program where an expression is allowed. An IIFE can be named, as with <code>hideTheCache()</code>, or (much more commonly!) unnamed/anonymous. And it can be standalone or, as before, part of another statement—<code>hideTheCache()</code> returns the <code>factorial()</code> function reference which is then <code>=</code> assigned to the variable <code>factorial</code>.</p><h3 id="388bf0e5-104c-442c-bbcd-d538ff469013" class=""><strong>Function Boundaries</strong></h3><p id="e1c43781-f52f-46fc-abce-b048dfee6879" class="">Beware that using an IIFE to define a scope can have some unintended consequences, depending on the code around it. Because an IIFE is a full function, the function boundary alters the behavior of certain statements/constructs.</p><p id="8229e28b-912f-4663-8848-c4f5ef1c03ee" class="">For example, a <code>return</code> statement in some piece of code would change its meaning if an IIFE is wrapped around it, because now the <code>return</code> would refer to the IIFE&#x27;s function. Non-arrow function IIFEs also change the binding of a <code>this</code> keyword—more on that in the <em>Objects &amp; Classes</em> book. And statements like <code>break</code> and <code>continue</code> won&#x27;t operate across an IIFE function boundary to control an outer loop or block.</p><p id="f524316a-b71b-4573-9277-f2448ff0b58a" class="">So, i<mark class="highlight-yellow_background">f the code you need to wrap a scope around has </mark><mark class="highlight-yellow_background"><code>return</code></mark><mark class="highlight-yellow_background">, </mark><mark class="highlight-yellow_background"><code>this</code></mark><mark class="highlight-yellow_background">, </mark><mark class="highlight-yellow_background"><code>break</code></mark><mark class="highlight-yellow_background">, or </mark><mark class="highlight-yellow_background"><code>continue</code></mark><mark class="highlight-yellow_background"> in it, an IIFE is probably not the best approach. In that case, you might look to create the scope with a block instead of a function.</mark></p><h3 id="453bae73-9cff-418b-8c01-abc57d581314" class="">Scoping with Blocks</h3><p id="13f5ec0b-717a-47ba-ad25-d4fec0704c23" class="">But let&#x27;s now consider using <code>let</code> declarations with nested blocks. In general, <mark class="highlight-yellow_background">any </mark><mark class="highlight-yellow_background"><code>{ .. }</code></mark><mark class="highlight-yellow_background"> curly-brace pair which is a statement will act as a block, but </mark><mark class="highlight-yellow_background"><strong>not necessarily</strong></mark><mark class="highlight-yellow_background"> as a scope.</mark></p><p id="596a230a-d574-465b-8629-878d91b6a4a7" class="">A block only becomes a scope if necessary, to contain its block-scoped declarations (i.e., <code>let</code> or <code>const</code>). Consider:</p><pre id="a935c9a5-5978-4902-9be7-0311b53a5e59" class="code"><code>{
    // not necessarily a scope (yet)

    // ..

    // now we know the block needs to be a scope
    let thisIsNowAScope = true;

    for (let i = 0; i &lt; 5; i++) {
        // this is also a scope, activated each
        // iteration
        if (i % 2 == 0) {
            // this is just a block, not a scope
            console.log(i);
        }
    }
}
// 0 2 4</code></pre><p id="a81842da-8bcb-42b5-87ac-6765efd74320" class="">Not all <code>{ .. }</code> curly-brace pairs create blocks (and thus are eligible to become scopes):</p><ul id="df03a427-484c-4043-8b70-d74f8e26cfe8" class="bulleted-list"><li style="list-style-type:disc">Object literals use <code>{ .. }</code> curly-brace pairs to delimit their key-value lists, but such object values are <strong>not</strong> scopes.</li></ul><ul id="b6b52aae-283b-4d8d-b144-6c502f7057f7" class="bulleted-list"><li style="list-style-type:disc"><code>class</code> uses <code>{ .. }</code> curly-braces around its body definition, but this is not a block or scope.</li></ul><ul id="388c6006-9035-464a-a541-09091e2e28d6" class="bulleted-list"><li style="list-style-type:disc">A <code>function</code> uses <code>{ .. } </code>around its body, but this is not technically a block—it&#x27;s a single statement for the function body. It <em>is</em>, however, a (function) scope.</li></ul><ul id="c3af5def-1ef0-419e-a225-dba825aa4c1b" class="bulleted-list"><li style="list-style-type:disc">The <code>{ .. }</code> curly-brace pair on a <code>switch</code> statement (around the set of <code>case</code> clauses) does not define a block/scope.</li></ul><p id="3cc4305c-2f98-4c30-9901-e35a631a6727" class="">Other than such non-block examples, a <code>{ .. }</code> curly-brace pair can define a block attached to a statement (like an <code>if</code> or <code>for</code>), or stand alone by itself—see the outermost <code>{ .. }</code> curly brace pair in the previous snippet. An explicit block of this sort—if it has no declarations, it&#x27;s not actually a scope—serves no operational purpose, though it can still be useful as a semantic signal.</p><p id="c5310265-7323-4d57-b70c-fb0d70286634" class="">Explicit standalone <code>{ .. }</code> blocks have always been valid JS syntax, but since they couldn&#x27;t be a scope prior to ES6&#x27;s <code>let</code>/<code>const</code>, they are quite rare. However, post ES6, they&#x27;re starting to catch on a little bit.</p><p id="4765fc31-4ffb-4fd7-8deb-6c920d7bd9ec" class="">S<mark class="highlight-yellow_background">o following the POLE principle, we should embrace this pattern more widespread in JS as well; use (explicit) block scoping to narrow the exposure of identifiers to the minimum practical.</mark></p><p id="37643c2d-4dc5-4f76-83fd-c12d0168c5be" class="">An explicit block scope can be useful even inside of another block (whether the outer block is a scope or not).</p><p id="c30b8cdb-70ae-4636-aec7-5f957014c7f7" class="">For example:</p><pre id="270ca4a9-8df8-44a4-8654-98b722a87be3" class="code"><code>if (somethingHappened) {
    // this is a block, but not a scope

    {
        // this is both a block and an
        // explicit scope
        let msg = somethingHappened.message();
        notifyOthers(msg);
    }

    // ..

    recoverFromSomething();
}</code></pre><p id="d9e4044c-00f6-43ef-9b93-070b9e2e4e0d" class="">Here, the <code>{ .. }</code> curly-brace pair <strong>inside</strong> the <code>if</code> statement is an even smaller inner explicit block scope for <code>msg</code>, since that variable is not needed for the entire <code>if</code> block. Most developers would just block-scope <code>msg</code> to the <code>if</code> block and move on. And to be fair, when there&#x27;s only a few lines to consider, it&#x27;s a toss-up judgement call. But as code grows, these over-exposure issues become more pronounced.</p><p id="543e7060-f414-4359-9a0e-66a7c23501a6" class="">So does it matter enough to add the extra <code>{ .. }</code> pair and indentation level? I think you should follow POLE and always (within reason!) define the smallest block for each variable. So I recommend using the extra explicit block scope as shown.</p><pre id="017b8446-1f0d-4764-a801-e4a8031213c0" class="code"><code>function getNextMonthStart(dateStr) {
    var nextMonth, year; //var indecates that the variables are needed in the entire function

    {
        let curMonth;
        [ , year, curMonth ] = dateStr.match(
                /(\d{4})-(\d{2})-\d{2}/) || [];
        nextMonth = (Number(curMonth) % 12) + 1;
    }

    if (nextMonth == 1) {
        year++;
    }

    return `${ year }-${            String(nextMonth).padStart(2,&quot;0&quot;)        }-01`;
}
getNextMonthStart(&quot;2019-12-25&quot;);   // 2020-01-01</code></pre><p id="03a7e3ae-dcd7-47cd-b7a0-a44f9d810799" class="">Let&#x27;s first identify the scopes and their identifiers:</p><ol type="1" id="d0e18b2d-b204-4129-9166-f2972560a50f" class="numbered-list" start="1"><li>The outer/global scope has one identifier, the function <code>getNextMonthStart(..)</code>.</li></ol><ol type="1" id="0a563347-a711-4fa3-9ad3-0aa23bcc9f77" class="numbered-list" start="2"><li>The function scope for <code>getNextMonthStart(..)</code> has three: <code>dateStr</code> (parameter), <code>nextMonth</code>, and <code>year</code>.</li></ol><ol type="1" id="1cd6b9ac-11b1-4df1-be4c-ef9f46f9974a" class="numbered-list" start="3"><li>The <code>{ .. }</code> curly-brace pair defines an inner block scope that includes one variable: <code>curMonth</code>.</li></ol><p id="3ef191f8-812a-4541-b8fb-6289a10bf81e" class="">So why put <code>curMonth</code> in an explicit block scope instead of just alongside <code>nextMonth</code> and <code>year</code> in the top-level function scope? B<mark class="highlight-yellow_background">ecause </mark><mark class="highlight-yellow_background"><code>curMonth</code></mark><mark class="highlight-yellow_background"> is only needed for those first two statements; at the function scope level it&#x27;s over-exposed.</mark></p><h3 id="b0a5e304-7ee9-437c-b5a3-2f1112ed1315" class=""><code>var</code> and <code>let</code></h3><p id="3d502ca9-758a-4e19-b6af-35b9183fd8e5" class=""><mark class="highlight-yellow_background">Stylistically, </mark><code><mark class="highlight-red">var</mark></code><mark class="highlight-yellow_background"> has always, from the earliest days of JS, signaled &quot;variable that belongs to a whole function.&quot;</mark></p><pre id="738c6269-2ea6-4267-b7d4-39ef141d07da" class="code code-wrap"><code>function diff(x,y) {
    if (x &gt; y) {
        var tmp = x;    // `tmp` is function-scoped
        x = y;
        y = tmp;
    }

    return y - x;
}</code></pre><p id="0ba8da2e-2168-4598-a833-be1f670b565a" class="">&quot;What is the most minimal scope exposure that&#x27;s sufficient for this variable?&quot; —&gt; you&#x27;ll know if a variable belongs in a block scope or the function scope. If you decide initially that a variable should be block-scoped, and later realize it needs to be elevated to be function-scoped, then that dictates a change not only in the location of that variable&#x27;s declaration, but also the declarator keyword used. The decision-making process really should proceed like that.</p><p id="ade533d0-ef6d-44e0-86ec-90a87b158c0c" class="">If a declaration belongs in a block scope, use <code>let</code>. If it belongs in the function scope, use <code>var</code> (again, just my opinion).</p><pre id="a4902fe6-3d12-4438-be60-6b9fabb4a8c6" class="code code-wrap"><code>try {
    doesntExist();
}
catch (err) {
    console.log(err);
    // ReferenceError: &#x27;doesntExist&#x27; is not defined
    // ^^^^ message printed from the caught exception

    let onlyHere = true;
    var outerVariable = true;
}

console.log(outerVariable);     // true

console.log(err);
// ReferenceError: &#x27;err&#x27; is not defined
// ^^^^ this is another thrown (uncaught) exception

new syntax replacement:

try {
    doOptionOne();
}
catch {   // catch-declaration omitted
    doOptionTwoInstead();
}</code></pre><h3 id="a5856b65-99b9-46ff-b614-d3683dd7c2d7" class="">Function Declarations in Blocks (FiB)</h3><pre id="ba129ff2-2ada-42d7-8b2f-29fc7f335444" class="code"><code>if (false) {
    function ask() {
        console.log(&quot;Does this run?&quot;);
    }
}
ask();</code></pre><p id="54119dce-3ffc-4e20-be89-a65184b38a60" class="">What do you expect for this program to do? Three reasonable outcomes:</p><ol type="1" id="96bd1cc3-dfc1-4727-bd52-59164dfcde69" class="numbered-list" start="1"><li>The <code>ask()</code> call might fail with a <code>ReferenceError</code> exception, because the <code>ask</code> identifier is block-scoped to the <code>if</code> block scope and thus isn&#x27;t available in the outer/global scope.</li></ol><ol type="1" id="f6f76242-0be1-4090-af0d-28a362f4946b" class="numbered-list" start="2"><li>The <code>ask()</code> call might fail with a <code>TypeError</code> exception, because the <code>ask</code> identifier exists, but it&#x27;s <code>undefined</code> (since the <code>if</code> statement doesn&#x27;t run) and thus not a callable function.</li></ol><ol type="1" id="79f1aa80-971d-4830-91ba-77cc797937aa" class="numbered-list" start="3"><li>The <code>ask()</code> call might run correctly, printing out the &quot;Does it run?&quot; message.</li></ol><p id="21e6fc43-6602-4d43-bd9b-ff7459badbc6" class="">Here&#x27;s the confusing part: depending on which JS environment you try that code snippet in, you may get different results! This is one of those few crazy areas where existing legacy behavior betrays a predictable outcome.</p><p id="0a795fa0-8509-4d16-a438-aa2a6ac7a85a" class=""><mark class="highlight-yellow_background">The JS specification says that </mark><mark class="highlight-yellow_background"><code>function</code></mark><mark class="highlight-yellow_background"> declarations inside of blocks are block-scoped, so the answer should be (1)</mark>. However, <mark class="highlight-yellow_background">most browser-based JS engines (including v8, which comes from Chrome but is also used in Node) will behave as (2)</mark>, meaning the identifier is scoped outside the <code>if</code> block but the function value is not automatically initialized, so it remains <code>undefined</code>.</p><p id="3461f4dc-e0e3-40f3-becb-e6ccbcf91e06" class="">Why are browser JS engines allowed to behave contrary to the specification? </p><p id="9b9ea629-dec5-489e-97bc-d28a78256840" class="">Because these engines already had certain behaviors around FiB before ES6 introduced block scoping, and there was concern that changing to adhere to the specification might break some existing website JS code. As such, an exception was made in Appendix B of the JS specification, which allows certain deviations for browser JS engines (only!).</p><p id="2c0134b0-d91e-4ee7-8641-54e1c3f856ba" class="">In addition to the risks of FiB deviations, <mark class="highlight-yellow_background">another problem with conditional-definition of functions is it&#x27;s harder to debug such a program.</mark> If you end up with a bug in the <code>isArray(..) </code>function, you first have to figure out <em>which </em><code>isArray(..) </code>implementation is actually running! Sometimes, the bug is that the wrong one was applied because the conditional check was incorrect! If you define multiple versions of a function, that program is always harder to reason about and maintain.</p><p id="1095817d-3dc8-4ecf-98cf-16a57cdfad0a" class=""><mark class="highlight-yellow_background">never place a function declaration directly inside any block. Always place function declarations anywhere in the top-level scope of a function (or in the global scope).</mark></p><figure id="b06cf26d-0015-4947-a29b-fd1b57d4f840" class="image"><a href="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2027.png"><img style="width:1002px" src="You%20Don&#x27;t%20Know%20JS%206b37c716505b4696b9161750d5617769/Untitled%2027.png"/></a></figure><p id="0bf9fe31-f872-47c9-8c89-7bf287ee4023" class="">It&#x27;s important to notice that here I&#x27;m placing a <code>function</code> <strong>expression</strong>, not a declaration, inside the <code>if</code> statement. That&#x27;s perfectly fine and valid, for <code>function</code> expressions to appear inside blocks. Our discussion about FiB is about avoiding <code>function</code> <strong>declarations</strong> in blocks.</p><h1 id="ccbae0fb-3364-4ab5-811c-b732158e6676" class="">Chapter 2.7: Using Closures</h1><p id="f884e289-ed91-4174-8986-74531c4f838f" class="">Closure builds on this approach: for variables we need to use over time, instead of placing them in larger outer scopes, we can encapsulate (more narrowly scope) them but still preserve access from inside functions, for broader use. Functions <em>remember</em> these referenced scoped variables via closure.</p><p id="39b96958-b8ea-4716-b77d-c36f0cea84fe" class="">Closure is a behavior of functions and only functions. If you aren&#x27;t dealing with a function, closure does not apply. An object cannot have closure, nor does a class have closure (though its functions/methods might). Only functions have closure.</p><p id="5529bc3d-69ab-40f3-899d-7259113cba0b" class="">For closure to be observed, a function must be invoked, and specifically it must be invoked in a different branch of the scope chain from where it was originally defined. A function executing in the same scope it was defined would not exhibit any observably different behavior with or without closure being possible; by the observational perspective and definition, that is not closure.</p><h3 id="4342ae22-7d43-4917-9014-40e374257986" class="">See the Closure</h3><div id="67da411f-6b67-44b3-90cb-9159e5f56482" class="column-list"><div id="b63e7d6e-8747-453c-b8ce-e10df53460c5" style="width:50%" class="column"><pre id="51b31de8-0f4a-4f68-8b41-17c917a64c3c" class="code"><code>// outer/global scope: RED(1)

function lookupStudent(studentID) {
    // function scope: BLUE(2)

    var students = [
        { id: 14, name: &quot;Kyle&quot; },
        { id: 73, name: &quot;Suzy&quot; },
        { id: 112, name: &quot;Frank&quot; },
        { id: 6, name: &quot;Sarah&quot; }
    ];

    return function greetStudent(greeting){
        // function scope: GREEN(3)

        var student = students.find(
            student =&gt; student.id == studentID
        );
				//student.id == studenID belongs in  function scope: ORANGE(4)
        return `${ greeting }, ${ student.name }!`;
    };
}

var chosenStudents = [
    lookupStudent(6),
    lookupStudent(112)
];

// accessing the function&#x27;s name:
chosenStudents[0].name;
// greetStudent

chosenStudents[0](&quot;Hello&quot;);
// Hello, Sarah!

chosenStudents[1](&quot;Howdy&quot;);
// Howdy, Frank!</code></pre></div><div id="7a3a7a0b-d320-49dd-ae71-0b15f294b156" style="width:50%" class="column"><p id="3abb50e9-a270-4e36-a4c0-a8ce099c245c" class="">The first thing to notice about this code is that the <code>lookupStudent(..)</code> outer function creates and returns an inner function called <code>greetStudent(..)</code>. <code>lookupStudent(..)</code> is called twice, producing two separate instances of its inner <code>greetStudent(..)</code> function, both of which are saved into the <code>chosenStudents</code> array.</p><p id="711ad9f8-726f-4ba9-bfe9-86a9bf8e698d" class="">We verify that&#x27;s the case by checking the <code>.name</code> property of the returned function saved in <code>chosenStudents[0]</code>, and it&#x27;s indeed an instance of the inner <code>greetStudent(..)</code>.</p><p id="89147455-6e4b-402d-8ca7-b0943f4bafbc" class="">After each call to <code>lookupStudent(..)</code> finishes, it would seem like all its inner variables would be discarded and GC&#x27;d (garbage collected). The inner function is the only thing that seems to be returned and preserved. But here&#x27;s where the behavior differs in ways we can start to observe.</p><p id="6acf208f-9c8a-4061-bdc4-a8a81f629a03" class="">While <code>greetStudent(..)</code> does receive a single argument as the parameter named <code>greeting</code>, it also makes reference to both <code>students</code> and <code>studentID</code>, identifiers which come from the enclosing scope of <code>lookupStudent(..)</code>. Each of those references from the inner function to the variable in an outer scope is called a <em>closure</em>. In academic terms, each instance of <code>greetStudent(..)</code> <em>closes over</em> the outer variables <code>students</code> and <code>studentID</code>.</p></div></div><p id="a5133d5b-3139-48f9-a62b-e6d7be8da9ea" class="">Closure allows <code>greetStudent(..)</code> to continue to access those outer variables even after the outer scope is finished (when each call to <code>lookupStudent(..)</code> completes). Instead of the instances of <code>students</code> and <code>studentID</code> being GC&#x27;d, they stay around in memory. At a later time when either instance of the <code>greetStudent(..)</code> function is invoked, those variables are still there, holding their current values.</p><h3 id="e5f26de0-cb11-4bba-aa5e-293c477c66db" class="">Pointed Closure</h3><p id="49f92bb3-7d6e-4354-b5d0-67ebe2f2a2ac" class=""><a href="https://www.javascripttutorial.net/javascript-callback/">Callbacks</a>: a callback is a function passed into another function as an argument to be executed later.</p><pre id="58c39677-1542-4979-a8a3-b4eb40abeecd" class="code"><code>var student = students.find(
    student =&gt;
        // function scope: ORANGE(4)
        student.id == studentID
);</code></pre><p id="c38d7da9-73f4-45f6-9546-d2d8348ca791" class="">The BLUE(2) <code>studentID</code> reference is actually inside the ORANGE(4) scope rather than the GREEN(3) scope of <code>greetStudent(..)</code>; also, the <code>student</code> parameter of the arrow function is ORANGE(4), shadowing the GREEN(3) <code>student</code>.</p><p id="5694216e-a261-4e3b-9dd9-727b2f4d9738" class="">The consequence here is that t<mark class="highlight-yellow_background">his arrow function passed as a callback to the array&#x27;s </mark><mark class="highlight-yellow_background"><code>find(..)</code></mark><mark class="highlight-yellow_background"> method has to hold the closure over </mark><mark class="highlight-yellow_background"><code>studentID</code></mark>, rather than <code>greetStudent(..)</code> holding that closure. That&#x27;s not too big of a deal, as everything still works as expected. It&#x27;s just important not to skip over the fact that even tiny arrow functions can get in on the closure party.<div class="indented"><p id="1d566240-89ea-4269-b6a5-2a8cda1f345a" class="block-color-orange_background">Terminology: </p><ul id="374d873d-ca5d-43d1-960b-51e41e3ba5f0" class="bulleted-list"><li style="list-style-type:disc">&lt;Inner function name&gt; holds closure over &lt;variable name from outer function&gt; </li></ul><ul id="b62f9be3-b579-49cf-bfc8-9df3d026785e" class="bulleted-list"><li style="list-style-type:disc">An instance of the &lt;inner function name&gt; is closing over &lt;variable name from outer function&gt;</li></ul><ul id="bff502d8-7498-4433-bfa0-be85957f0e34" class="bulleted-list"><li style="list-style-type:disc">The &lt;variable name from outer function&gt; variable is closed over by the inner &lt;inner function name&gt;  function</li></ul><pre id="8f37d131-65ef-4cb5-a41b-586c261636f3" class="code code-wrap"><code>function makeCounter() {
    var count = 0;

    return function getCurrent() {
        count = count + 1;
        return count;
    };
}

var hits = makeCounter();

// later

hits();     // 1

// later

hits();     // 2
hits();     // 3</code></pre></div></p><h3 id="1b32866e-faf7-428d-9c04-c9d4844b8b70" class="">Adding Up Closures</h3><div id="af889015-0254-4ad4-999d-5ccaf570964f" class="column-list"><div id="acdf8f2e-ff93-4f18-a013-4f2893e75307" style="width:50%" class="column"><pre id="96d5cf0d-dcbf-4f87-9bf6-2bef3f34e9e8" class="code"><code>function adder(num1) {
    return function addTo(num2){
        return num1 + num2;
    };
}

var add10To = adder(10);
var add42To = adder(42);

add10To(15);    // 25
add42To(9);     // 51</code></pre></div><div id="371c4d4f-c4bd-4efd-9199-c8b4e49daa4f" style="width:50%" class="column"><figure id="ea6ecb62-a4d9-400d-b5f4-06548db4ecb4" class="image"><a href="https://github.com/getify/You-Dont-Know-JS/raw/2nd-ed/scope-closures/images/fig4.png"><img src="https://github.com/getify/You-Dont-Know-JS/raw/2nd-ed/scope-closures/images/fig4.png"/></a></figure><p id="e7875bb7-12d1-4ea0-a06f-c31350c9d5ad" class=""><em>Fig. 4: Visualizing Closures</em></p><p id="957632fc-7793-4066-835c-3d8450d9356f" class="">As shown in Figure 4, each call to <code>adder(..)</code> creates a new BLUE(2) scope containing a <code>num1</code> variable, as well as a new instance of <code>addTo(..)</code> function as a GREEN(3) scope. Notice that the function instances (<code>addTo10(..)</code> and <code>addTo42(..)</code>) are present in and invoked from the RED(1) scope.</p></div></div><p id="735c6705-bf53-4dc6-81ec-f75957a6bb43" class="">Each instance of the inner <code>addTo(..)</code> function is closing over its own <code>num1</code> variable (with values <code>10</code> and <code>42</code>, respectively), so those <code>num1</code>&#x27;s don&#x27;t go away just because <code>adder(..)</code> finishes. When we later invoke one of those inner <code>addTo(..)</code> instances, such as the <code>add10To(15)</code> call, its closed-over <code>num1</code> variable still exists and still holds the original <code>10</code> value. The operation is thus able to perform <code>10 + 15</code> and return the answer <code>25</code>.</p><p id="698f509f-985f-4b50-9cba-4120b1ce4fe9" class="block-color-yellow_background">closure is associated with an instance of a function, rather than its single lexical definition.</p><p id="42975694-6925-4309-abc7-f0e68a57ecb9" class="">But actually, every time the outer <code>adder(..)</code> function runs, a <em>new</em> inner <code>addTo(..)</code> function instance is created, and for each new instance, a new closure. So each inner function instance (labeled <code>add10To(..)</code> and <code>add42To(..)</code> in our program) has its own closure over its own instance of the scope environment from that execution of <code>adder(..)</code>.</p><h3 id="c5422953-e76f-4110-b153-85c6e3a13591" class="">Live Link, Not a Snapshot</h3><p id="e89009ab-5a85-4b8e-b66c-e78608990d42" class="">We&#x27;re not limited to merely reading a value; the closed-over variable can be updated (re-assigned) as well! By closing over a variable in a function, we can keep using that variable (read and write) as long as that function reference exists in the program, and from anywhere we want to invoke that function. </p><pre id="ec775fcd-aff2-4c08-98b4-db45012f01e8" class="code code-wrap"><code>function makeCounter() {
    var count = 0;

    return function getCurrent() {
        count = count + 1;
        return count;
    };
}

var hits = makeCounter();

// later

hits();     // 1

// later

hits();     // 2
hits();     // 3</code></pre><p id="c6114220-33c3-46c3-a770-49808288320f" class="">Though the enclosing scope of a closure is typically from a function, that&#x27;s not actually required; there only needs to be an inner function present inside an outer scope:</p><pre id="0ad915d3-eb0a-4758-b7a7-ef626061737d" class="code"><code>var hits; // hits is later defined as a function
{   // an outer scope (but not a function)
    let count = 0;
    hits = function getCurrent(){
        count = count + 1;
        return count;
    };
}
hits();     // 1
hits();     // 2
hits();     // 3</code></pre><p id="808f4293-8960-444b-aeb6-34e52c804af7" class="">closure is variable-oriented, not value-oriented </p><div id="f458c43c-b674-4669-8325-5b62973d76aa" class="column-list"><div id="616afdda-6bb3-4832-bad0-8eb2c9e92466" style="width:50%" class="column"><pre id="f9e5ef6b-8944-41c6-a178-4fea9681e5f6" class="code"><code>var studentName = &quot;Frank&quot;;

var greeting = function hello() {
    // we are closing over `studentName`,
    // not &quot;Frank&quot;
    console.log(
        `Hello, ${ studentName }!`
    );
}

// later

studentName = &quot;Suzy&quot;;

// later

greeting();
// Hello, Suzy!</code></pre></div><div id="f0161eb1-22bf-4b76-beec-e58bd6ec1a0f" style="width:50%" class="column"><pre id="4208f3ab-50dc-4503-a7fe-57cb3e6cfa12" class="code code-wrap"><code>var keeps = [];

for (var i = 0; i &lt; 3; i++) {
    keeps[i] = function keepI(){
        // closure over `i`
        return i;
    };
}

keeps[0]();   // 3 
//because var is function scoping. 
//better to use let in for loop
keeps[1]();   // 3
keeps[2]();   // 3</code></pre></div></div><h3 id="952b9284-824a-4525-bb31-3ebce1aa93f8" class="">Common Closures: Ajax and Events</h3><p id="03143cb2-5da2-4920-954e-70fb82c2effa" class="">Closure is most commonly encountered with callbacks:</p><pre id="b78bb854-d186-448c-a498-5d19c547c407" class="code"><code>function lookupStudentRecord(studentID) {
    ajax(
        `https://some.api/student/${ studentID }`,
        function onRecord(record) {
            console.log(
                `${ record.name } (${ studentID })` //closing over studentID 
            );
        }
    );
}

lookupStudentRecord(114);
// Frank (114)</code></pre><p id="48d57241-3a7c-446c-a45a-91087d6f9f43" class="">Event handlers are another common usage of closure:</p><pre id="9c53893a-0e31-4078-a34c-87540300489f" class="code"><code>function listenForClicks(btn,label) {
    btn.addEventListener(&quot;click&quot;,function onClick(){
        console.log(
            `The ${ label } button was clicked!`//closing over label
        );
    });
}

var submitBtn = document.getElementById(&quot;submit-btn&quot;);

listenForClicks(submitBtn,&quot;Checkout&quot;);</code></pre><p id="858f9399-e646-4c71-b59c-68b9f3615755" class="">The <code>label</code> parameter is closed over by the <code>onClick(..)</code> event handler callback. When the button is clicked, <code>label</code> still exists to be used. This is closure.</p><h3 id="8a878bc1-7a6f-49c6-aef7-b1f7407f2dd2" class="">What If I Can&#x27;t See It?</h3><p id="28419b37-81c8-4b65-8a73-0d67f3dc0a4c" class="">In fact, global scope variables essentially cannot be (observably) closed over, because they&#x27;re always accessible from everywhere. No function can ever be invoked in any part of the scope chain that is not a descendant of the global scope.</p><pre id="8afcb832-2179-40ff-95dd-b27b19b2ff7b" class="code"><code>var students = [
    { id: 14, name: &quot;Kyle&quot; },
    { id: 73, name: &quot;Suzy&quot; },
    { id: 112, name: &quot;Frank&quot; },
    { id: 6, name: &quot;Sarah&quot; }
];

function getFirstStudent() {
    return function firstStudent(){
        return students[0].name;
    };
}

var student = getFirstStudent();

student();
// Kyle</code></pre><p id="00e84c44-7aff-4982-9680-c85f5c286b03" class="">The inner <code>firstStudent()</code> function does reference <code>students</code>, which is a variable outside its own scope. But since <code>students</code> happens to be from the global scope, no matter where that function is invoked in the program, its ability to access <code>students</code> is nothing more special than normal lexical scope.</p><p id="800b0489-265e-40a0-a679-d9d50d286c02" class="">Variables that are merely present but never accessed don&#x27;t result in closure:</p><pre id="cf46eea1-e146-47b1-81a8-3eab450cfb2e" class="code"><code>function lookupStudent(studentID) {
    return function nobody(){
        var msg = &quot;Nobody&#x27;s here yet.&quot;;
        console.log(msg);
    };
}

var student = lookupStudent(112);

student();
// Nobody&#x27;s here yet.</code></pre><p id="ce43a036-83e1-4c4c-91b8-b353f3c16ea8" class="">The inner function <code>nobody()</code> doesn&#x27;t close over any outer variables—it only uses its own variable <code>msg</code>. Even though <code>studentID</code> is present in the enclosing scope, <code>studentID</code> is not referred to by <code>nobody()</code>.<mark class="highlight-yellow_background"> The JS engine doesn&#x27;t need to keep </mark><mark class="highlight-yellow_background"><code>studentID</code></mark><mark class="highlight-yellow_background"> around after </mark><mark class="highlight-yellow_background"><code>lookupStudent(..)</code></mark><mark class="highlight-yellow_background"> has finished running, so</mark> GC wants to clean up that memory!</p><p id="a6d5dcae-2f1e-4420-a58b-53822dcab3eb" class="">If there&#x27;s no function invocation, closure can&#x27;t be observed:</p><pre id="a8e5c51b-0864-424d-a085-fb15297ecacd" class="code"><code>function greetStudent(studentName) {
    return function greeting(){
        console.log(
            `Hello, ${ studentName }!`
        );
    };
}

greetStudent(&quot;Kyle&quot;);

// nothing else happens</code></pre><p id="43b4e4df-7b4c-4922-a4d3-41f1754717d7" class="">This one&#x27;s tricky, because the outer function definitely does get invoked. <strong>But the inner function is the one that </strong><strong><em>could</em></strong><strong> have had closure, and yet it&#x27;s never invoked; the returned function here is just thrown away. So even if technically the JS engine created closure for a brief moment, it was not observed in any meaningful way in this program.</strong></p><h3 id="f160d32b-e53e-41f0-97f0-2f0733e8ff8c" class="">Observable Definition</h3><p id="34fa7884-344b-45a6-a404-53ba8ff38d5d" class=""><mark class="highlight-yellow_background">Closure is observed when a function uses variable(s) from outer scope(s) even while running in a scope where those variable(s) wouldn&#x27;t be accessible.</mark></p><ul id="2df3e3a2-fd08-4120-9278-c16ba716c928" class="bulleted-list"><li style="list-style-type:disc">Must be a function involved</li></ul><ul id="58d41e07-db89-49c0-bd12-d0ff6b563c18" class="bulleted-list"><li style="list-style-type:disc">Must reference at least one variable from an outer scope</li></ul><ul id="97377cfb-faa8-4d7f-af3c-6de881805585" class="bulleted-list"><li style="list-style-type:disc">Must be invoked in a different branch of the scope chain from the variable(s)</li></ul><p id="a34404f6-0175-4221-9820-2afbfb81a8bb" class="">This observation-oriented definition means we shouldn&#x27;t dismiss closure as some indirect, academic trivia. Instead, we should look and plan for the direct, concrete effects closure has on our program behavior.</p><h3 id="2688fcef-3b98-498d-8f0e-8e56c114f57e" class="">The Closure Lifecycle and Garbage Collection (GC)</h3><p id="9d9eec58-6069-4d22-9b8d-903fea782330" class="">Since closure is inherently tied to a function instance, its closure over a variable lasts as long as there is still a reference to that function. Once the final function reference is discarded, the last closure over that variable is gone, and the variable itself is GC&#x27;d.</p><div id="e16e8043-3d07-4820-9433-50d551d42979" class="column-list"><div id="ab0f11e3-2a18-4875-b18b-f27f7570a9fe" style="width:68.75%" class="column"><pre id="69aeaec8-00c1-44ca-8c0a-282c3b579baa" class="code code-wrap"><code>function manageBtnClickEvents(btn) {
    var clickHandlers = [];

    return function listener(cb){
        if (cb) {
            let clickHandler =
                function onClick(evt){
                    console.log(&quot;clicked!&quot;);
                    cb(evt);
                };
            clickHandlers.push(clickHandler);
            btn.addEventListener(
                &quot;click&quot;,
                clickHandler
            );
        }
        else {
            // passing no callback unsubscribes
            // all click handlers
            for (let handler of clickHandlers) {
                btn.removeEventListener(
                    &quot;click&quot;,
                    handler
                );
            }

            clickHandlers = [];
        }
    };
}

// var mySubmitBtn = ..
var onSubmit = manageBtnClickEvents(mySubmitBtn);

onSubmit(function checkout(evt){
    // handle checkout
});

onSubmit(function trackAction(evt){
    // log action to analytics
});

// later, unsubscribe all handlers:
onSubmit();</code></pre></div><div id="eaa478b1-9439-49c8-9041-635d68ada502" style="width:31.25%" class="column"><p id="b43f1ca8-744e-4b34-9b91-4edc75ffea9b" class="">In this program, the inner <code>onClick(..)</code> function holds a closure over the passed in <code>cb</code> (the provided event callback). That means the <code>checkout()</code> and <code>trackAction()</code> function expression references are held via closure (and cannot be GC&#x27;d) for as long as these event handlers are subscribed.</p><p id="26294374-6bfb-42cd-809f-6eedcce63af2" class="">When we call <code>onSubmit()</code> with no input on the last line, all event handlers are unsubscribed, and the <code>clickHandlers</code> array is emptied. Once all click handler function references are discarded, the closures of <code>cb</code> references to <code>checkout()</code> and <code>trackAction()</code> are discarded.</p><p id="573bb76d-b81b-4806-bfda-771e9161c613" class=""><mark class="highlight-yellow_background">When considering the overall health and efficiency of the program, unsubscribing an event handler when it&#x27;s no longer needed can be even more important than the initial subscription!</mark></p><p id="b4f8046f-0788-4217-9435-355fc3d1c7e1" class="">
</p><p id="54938966-beea-413b-9fa5-0b62cd68fdc8" class="">
</p><p id="8e156cc5-1088-4dc0-866e-075ae3a74f97" class="">
</p></div></div><h3 id="bbcfcc61-dcc4-4bef-8c7f-729abd3b8e98" class="">Per Scope and JS engines optimizes it to per variable</h3><p id="c5664294-96c8-49b9-ae14-97a2c46f4944" class="">closure is per variable rather than per scope. Ajax callbacks, event handlers, and all other forms of function closures are typically assumed to <mark class="highlight-yellow_background">close over only what they explicitly reference.</mark></p><p id="868c81c1-10fb-401b-ac2b-418242185fe2" class="">Many modern JS engines do apply an <em>optimization</em> that removes any variables from a closure scope that aren&#x27;t explicitly referenced. However, as we see with <code>eval(..)</code>, there are situations where such an optimization cannot be applied, and the closure scope continues to contain all its original variables. In other words, closure must be <em>per scope</em>, implementation wise, and then an optional optimization trims down the scope to only what was closed over (a similar outcome as <em>per variable</em> closure).</p><p id="ae8650b7-2b00-4999-a66e-c9597049c772" class="">And the fact that it&#x27;s an optional optimization in the first place, rather than a requirement of the specification, means that <mark class="highlight-yellow_background">we shouldn&#x27;t just casually over-assume its applicability</mark>.</p><p id="00a6e514-131d-449c-8de1-3f70bad14445" class=""><mark class="highlight-yellow_background">In cases where a variable holds a large value (like an object or array) and that variable is present in a closure scope, if you don&#x27;t need that value anymore and don&#x27;t want that memory held, it&#x27;s safer (memory usage) to manually discard the value rather than relying on closure optimization/GC.</mark></p><h3 id="a2afa750-cb78-4ddd-8d5d-9d7d7bffa833" class="">An Alternative Perspective - better </h3><p id="57cb9f5c-bf36-4815-80c5-30c788e2b682" class="">This alternative model de-emphasizes &quot;functions as first-class values,&quot; and instead embraces how functions (like all non-primitive values) are held by reference in JS, and assigned/passed by reference-copy</p><pre id="d5604e7a-176c-43b0-9a8b-a37b08894d34" class="code"><code>function adder(num1) {
    return function addTo(num2){
        return num1 + num2;
    };
}

var add10To = adder(10);
var add42To = adder(42);

add10To(15);    // 25
add42To(9);     // 51</code></pre><p id="c1be162c-1d7d-4922-b8a4-8501f34a75cb" class="">
</p><p id="905bc529-b5c9-4530-98fd-1c245abd8e11" class="">Instead of thinking about the inner function instance of <code>addTo(..)</code> moving to the outer RED(1) scope via the <code>return</code> and assignment, we can envision that function instances actually just stay in place in their own scope environment, of course with their scope-chain intact.</p><p id="9ba0029b-9397-4e97-943e-b050d668849b" class="">What gets <em>sent</em> to the RED(1) scope is <strong>just a reference</strong> to the in-place function instance, rather than the function instance itself. Figure 5 depicts the inner function instances remaining in place, pointed to by the RED(1) <code>addTo10</code> and <code>addTo42</code> references, respectively:</p><figure id="bab441b3-ee69-459f-b38d-fb441a805cfb" class="image"><a href="https://github.com/getify/You-Dont-Know-JS/raw/2nd-ed/scope-closures/images/fig5.png"><img style="width:288px" src="https://github.com/getify/You-Dont-Know-JS/raw/2nd-ed/scope-closures/images/fig5.png"/></a></figure><p id="e7e7d0f1-c681-45c3-b310-c8cd0f9d8155" class=""><em>Fig. 5: Visualizing Closures (Alternative)</em></p><p id="1ee5722b-cb46-4def-9ff7-638b9874f323" class="">As shown in Figure 5, each call to <code>adder(..)</code> still creates a new BLUE(2) scope containing a <code>num1</code> variable, as well as an instance of the GREEN(3) <code>addTo(..)</code> scope. But what&#x27;s different from Figure 4 is, now these GREEN(3) instances remain in place, naturally nested inside of their BLUE(2) scope instances. The <code>addTo10</code> and <code>addTo42</code> references are moved to the RED(1) outer scope, not the function instances themselves.</p><p id="73b2d666-862f-4f9a-bb62-25d952a0cb2c" class="">When <code>addTo10(15)</code> is called, the <code>addTo(..)</code> function instance (still in place in its original BLUE(2) scope environment) is invoked. Since the function instance itself never moved, of course it still has natural access to its scope chain. Same with the <code>addTo42(9)</code> call—nothing special here beyond lexical scope.</p><h3 id="d2677409-ef35-4197-8c25-e64c33d48237" class="">Why Closure?</h3><p id="de74e760-2474-49fb-8166-aab6084b1f79" class="">
</p><div id="02ef7c74-4dae-4367-8352-f8746b5dada9" class="column-list"><div id="51a77166-f302-482f-989a-f88b454a5a5c" style="width:43.75%" class="column"><pre id="4e5b94b9-f34f-4011-bce9-cd6670b7008f" class="code code-wrap"><code>var APIendpoints = {
    studentIDs:
        &quot;https://some.api/register-students&quot;,
    // ..
};

var data = {
    studentIDs: [ 14, 73, 112, 6 ],
    // ..
};

function makeRequest(evt) {
    var btn = evt.target;
    var recordKind = btn.dataset.kind;
    ajax(
        APIendpoints[recordKind],
        data[recordKind]
    );
}

// &lt;button data-kind=&quot;studentIDs&quot;&gt;
//    Register Students
// &lt;/button&gt;
btn.addEventListener(&quot;click&quot;,makeRequest);</code></pre><p id="1b3ae242-a053-4ebe-ba9b-0f40703b3d84" class="">the event handler has to read a DOM attribute each time it&#x27;s fired.</p></div><div id="f424abd3-16ff-4347-8454-aa42990bf96a" style="width:56.25%" class="column"><pre id="bb7d7b4f-81a3-4789-8999-3fff339a66c7" class="code code-wrap"><code>var APIendpoints = {
    studentIDs:
        &quot;https://some.api/register-students&quot;,
    // ..
};

var data = {
    studentIDs: [ 14, 73, 112, 6 ],
    // ..
};

function setupButtonHandler(btn) {
    var recordKind = btn.dataset.kind;

    btn.addEventListener(
        &quot;click&quot;,
        function makeRequest(evt){
            ajax(
                APIendpoints[recordKind],
                data[recordKind]
            );
        }
    );
}

// &lt;button data-kind=&quot;studentIDs&quot;&gt;
//    Register Students
// &lt;/button&gt;

setupButtonHandler(btn);</code></pre><p id="43f7617c-f2a4-492f-944b-98a575d7c3d9" class="">With the <code>setupButtonHandler(..)</code> approach, the <code>data-kind</code> attribute is retrieved once and assigned to the <code>recordKind</code> variable at initial setup. <code>recordKind</code> is then closed over by the inner <code>makeRequest(..)</code> click handler, and its value is used on each event firing to look up the URL and data that should be sent.</p></div></div><p id="ea0704c9-d9f7-4e45-ae31-49a410fa31e7" class="">more improvement</p><pre id="6717b90e-e169-4df1-8ae9-d04529cb0400" class="code code-wrap"><code>function setupButtonHandler(btn) {
    var recordKind = btn.dataset.kind;
    var requestURL = APIendpoints[recordKind];
    var requestData = data[recordKind];

    btn.addEventListener(
        &quot;click&quot;,
        function makeRequest(evt){
            ajax(requestURL,requestData);
        }
    );
}</code></pre><p id="df2603ea-31a1-4ab5-ba0d-116c25ce8cb9" class="">most improvement</p><div id="4ab78992-f9dd-4f09-942d-477ea07d1373" class="column-list"><div id="55afc5dd-0b87-44fa-9963-f79abffded14" style="width:50%" class="column"><pre id="aafe20e1-4471-4fb8-9513-10e6f0f4e01c" class="code code-wrap"><code>function defineHandler(requestURL,requestData) {
    return function makeRequest(evt){
        ajax(requestURL,requestData);
    };
}

function setupButtonHandler(btn) {
    var recordKind = btn.dataset.kind;
    var handler = defineHandler(
        APIendpoints[recordKind],
        data[recordKind]
    );
    btn.addEventListener(&quot;click&quot;,handler);
}</code></pre></div><div id="ab1e39dd-3226-4e16-8fff-833acf4905bb" style="width:50%" class="column"><p id="fed8c0cd-55b1-4b7b-aa39-c14b7e2cbe1c" class="">The <code>requestURL</code> and <code>requestData</code> inputs are provided ahead of time, resulting in the <code>makeRequest(..)</code> partially applied function, which we locally label <code>handler</code>. When the event eventually fires, the final input (<code>evt</code>, even though it&#x27;s ignored) is passed to <code>handler()</code>, completing its inputs and triggering the underlying Ajax request.</p><p id="ae420280-c91e-4b81-8408-99b41f477e30" class="">Behavior-wise, this program is pretty similar to the previous one, with the same type of closure. But by isolating the creation of <code>makeRequest(..)</code> in a separate utility (<code>defineHandler(..)</code>), we make that definition more reusable across the program. We also explicitly limit the closure scope to only the two variables needed.</p></div></div><h3 id="4eadf6dc-e871-4df7-b9b1-6fb079068fb1" class="">Summary - Close to Closure</h3><p id="7c33a3c7-6ed0-4f74-a236-04d9e1f3c8ff" class="">We explored two models for mentally tackling closure:</p><ul id="25208118-6f0c-4322-8d1b-9732c1b6bc82" class="bulleted-list"><li style="list-style-type:disc">Observational: closure is a function instance remembering its outer variables even as that function is passed to and <strong>invoked in</strong> other scopes.</li></ul><ul id="869d76ec-5bba-4a96-9fda-08e5c4e96de1" class="bulleted-list"><li style="list-style-type:disc">Implementational: closure is a function instance and its scope environment preserved in-place while any references to it are passed around and <strong>invoked from</strong> other scopes.</li></ul><p id="f4655d3a-989d-4caf-880b-6d228de07511" class="">Summarizing the benefits to our programs:</p><ul id="96bc6ca5-a043-4756-94a9-d72956a46502" class="bulleted-list"><li style="list-style-type:disc">Closure can improve efficiency by allowing a function instance to remember previously determined information instead of having to compute it each time.</li></ul><ul id="430f8129-ef95-4365-803a-478cd2eefbb6" class="bulleted-list"><li style="list-style-type:disc">Closure can improve code readability, bounding scope-exposure by encapsulating variable(s) inside function instances, while still making sure the information in those variables is accessible for future use. The resultant narrower, more specialized function instances are cleaner to interact with, since the preserved information doesn&#x27;t need to be passed in every invocation.</li></ul><h1 id="c9a6c72d-7691-45d5-8cde-1687307496e4" class="">Chapter 2.8: The Module Pattern</h1><h3 id="e107cd42-5b3c-4a33-b131-f7db4cc36e77" class="">Encapsulation and Least Exposure (POLE)</h3><p id="ce585b41-6325-4997-867c-a5a01528f47e" class="">The goal of encapsulation is the bundling or co-location of information (data) and behavior (functions) that together serve a common purpose.</p><p id="6b1bf3c1-62a4-42d7-9ece-083acc27a0b4" class="">Another key goal is the control of visibility of certain aspects of the encapsulated data and functionality.</p><p id="fca73dc5-8b6d-4132-bd2f-a5f6be8e6952" class="">The idea is to group alike program bits together, and selectively limit programmatic access to the parts we consider <em>private</em> details. What&#x27;s not considered <em>private</em> is then marked as <em>public</em>, accessible to the whole program.</p><h3 id="5cb285b6-ff23-42f4-ad1b-298c73459802" class="">What Is a Module?</h3><p id="59fe128f-2851-4a7d-b7fa-80d432dd07be" class="">A module is a collection of related data and functions (often referred to as methods in this context), characterized by a division between hidden <em>private</em> details and <mark class="highlight-yellow_background"><em>public</em></mark><mark class="highlight-yellow_background"> accessible details, usually called the &quot;public API.&quot;</mark></p><p id="4ecb2536-f222-4a1b-b536-724f48690a36" class="">A module is also stateful: it maintains some information over time, along with functionality to access and update that information.</p><h3 id="2e31a6f1-9341-4660-a1ca-749d38a4f14b" class=""><strong>Namespaces (Stateless Grouping)</strong></h3><p id="14da14c6-5416-41c4-93de-7e456c59928b" class="">If you group a set of related functions together, without data, then you don&#x27;t really have the expected encapsulation a module implies. The better term for this grouping of <em>stateless</em> functions is a namespace:</p><div id="0d58d8a0-d9aa-49af-bdaa-8ee434f304c5" class="column-list"><div id="0157fe30-59cd-4bfd-97fe-7fcdbda5ded7" style="width:62.5%" class="column"><pre id="b8164a47-2b57-4358-a7b8-68dfe17dcaea" class="code"><code>// namespace, not module
var Utils = {
    cancelEvt(evt) {
        evt.preventDefault();
        evt.stopPropagation();
        evt.stopImmediatePropagation();
    },
    wait(ms) {
        return new Promise(function c(res){
            setTimeout(res,ms);
        });
    },
    isValidEmail(email) {
        return /[^@]+@[^@.]+\.[^@.]+/.test(email);
    }
};</code></pre></div><div id="37c9e7c6-1234-42b4-9560-63d47aba071b" style="width:37.49999999999999%" class="column"><p id="23c14b64-e70c-4393-aecd-09741b1780cb" class=""><code>Utils</code> here is a useful collection of utilities, yet they&#x27;re all state-independent functions. Gathering functionality together is generally good practice, but that doesn&#x27;t make this a module. Rather, we&#x27;ve defined a <code>Utils</code> namespace and organized the functions under it.</p></div></div><h3 id="f8205f2b-2990-4712-a49d-a2b40dcd27b4" class=""><strong>Data Structures (Stateful Grouping)</strong></h3><p id="def00ff7-b3bd-42c7-aaaa-6c3d07bb34ca" class="">Even if you bundle data and stateful functions together, if you&#x27;re not limiting the visibility of any of it, then you&#x27;re stopping short of the POLE aspect of encapsulation; it&#x27;s not particularly helpful to label that a module.</p><p id="518572d6-c570-45c1-964b-34f522b7317e" class="">Consider:</p><div id="38bf68a1-324c-4d11-8d3e-149150ef5971" class="column-list"><div id="5f89b245-5145-4e4b-bca1-de5171218cac" style="width:68.75%" class="column"><pre id="8e37d5ca-4627-4779-9dbe-dedbe8cd1ab8" class="code"><code>// data structure, not module
var Student = {
    records: [
        { id: 14, name: &quot;Kyle&quot;, grade: 86 },
        { id: 73, name: &quot;Suzy&quot;, grade: 87 },
        { id: 112, name: &quot;Frank&quot;, grade: 75 },
        { id: 6, name: &quot;Sarah&quot;, grade: 91 }
    ],
    getName(studentID) {
        var student = this.records.find(
            student =&gt; student.id == studentID
        );
        return student.name;
    }
};

Student.getName(73);
// Suzy</code></pre></div><div id="81a31fd2-1212-40fa-bf4c-1c8a568f5428" style="width:31.25%" class="column"><p id="b6cf970b-bfc4-4ee0-9203-52e61faec2f8" class="">Since <code>records</code> is publicly accessible data, not hidden behind a public API, <code>Student</code> here isn&#x27;t really a module.</p><p id="2ad69ea0-54fe-4536-9517-721317988542" class=""><code>Student</code> does have the data-and-functionality aspect of encapsulation, but not the visibility-control aspect. It&#x27;s best to label this an instance of a data structure.</p></div></div><h3 id="eec89a40-6e7b-4dbc-baa2-a426db398c7f" class=""><strong>Modules (Stateful Access Control)</strong></h3><p id="c593a11a-6695-4532-b825-b51a5e657199" class="">To embody the full spirit of the module pattern, we not only need grouping and state, but also access control through visibility (private vs. public).</p><p id="9e337460-18ae-4db0-acf8-64ea74fbfacb" class="">Let&#x27;s turn <code>Student</code> from the previous section into a module. We&#x27;ll start with a form I call the &quot;classic module,&quot; which was originally referred to as the &quot;revealing module&quot; when it first emerged in the early 2000s. Consider:</p><pre id="37c4f94c-61c3-4d1d-b564-c6839c1cf0aa" class="code"><code>//Singleton module
var Student = (function defineStudent(){
    var records = [
        { id: 14, name: &quot;Kyle&quot;, grade: 86 },
        { id: 73, name: &quot;Suzy&quot;, grade: 87 },
        { id: 112, name: &quot;Frank&quot;, grade: 75 },
        { id: 6, name: &quot;Sarah&quot;, grade: 91 }
    ];

    var publicAPI = {
        getName
    };

    return publicAPI;

    // ************************

    function getName(studentID) {
        var student = records.find(
            student =&gt; student.id == studentID
        );
        return student.name;
    }
})();

Student.getName(73);   // Suzy</code></pre><p id="6de5fd6a-3bd5-4437-8b3f-27cc9813c1ce" class=""><code>Student</code> is now an instance of a module. It features a public API with a single method: <code>getName(..)</code>. This method is able to access the private hidden <code>records</code> data.</p><p id="04f45423-2008-4bfd-be46-f88439732b5d" class="">How does the classic module format work?</p><p id="9fec977f-7db8-4734-b320-922bcd1d7b54" class=""><mark class="highlight-yellow_background">Notice that the instance of the module is created by the </mark><mark class="highlight-yellow_background"><code>defineStudent()</code></mark><mark class="highlight-yellow_background"> IIFE being executed. This IIFE returns an object (named </mark><mark class="highlight-yellow_background"><code>publicAPI</code></mark><mark class="highlight-yellow_background">) that has a property on it referencing the inner </mark><mark class="highlight-yellow_background"><code>getName(..)</code></mark><mark class="highlight-yellow_background"> function.</mark></p><p id="0b3e2341-99d4-4d29-903e-40bfc56c7658" class="">Naming the object <code>publicAPI</code> is stylistic preference on my part. The object can be named whatever you like (JS doesn&#x27;t care), or you can just return an object directly without assigning it to any internal named variable. More on this choice in Appendix A.</p><p id="d21218aa-991a-4997-bb2a-b4c2b59a3152" class="">From the outside, <code>Student.getName(..)</code> invokes this exposed inner function, which maintains access to the inner <code>records</code> variable via closure.</p><p id="0352a296-3608-4639-b9e9-f5936c387441" class="block-color-yellow_background">You don&#x27;t <em>have</em> to return an object with a function as one of its properties. You could just return a function directly, in place of the object. That still satisfies all the core bits of a classic module.</p><p id="fd0eee04-c1fa-4fb3-9b9c-f11a2c8a7c7e" class="">By virtue of how lexical scope works, <mark class="highlight-yellow_background">defining variables and functions inside your outer module definition function makes everything </mark><mark class="highlight-yellow_background"><em>by default</em></mark><mark class="highlight-yellow_background"> private. </mark>Only properties added to the public API object returned from the function will be exported for external public use.</p><p id="a4a6ae1d-db91-4119-b502-f2a04fa81730" class=""><mark class="highlight-yellow_background">The use of an IIFE implies that our program only ever needs a single central instance of the module, commonly referred to as a &quot;singleton.&quot;</mark> </p><h3 id="5c1e9ab9-7058-4dfd-b4eb-aa0357fb7c14" class=""><strong>Module Factory (Multiple Instances)</strong></h3><p id="d1d75f75-1186-46b1-961e-74a04cfed270" class="">But if we did want to define a module that supported multiple instances in our program, we can slightly tweak the code:</p><pre id="a9fa948f-6b51-4346-b6a1-5787639fcafc" class="code"><code>// factory function, not singleton IIFE
function defineStudent() {
    var records = [
        { id: 14, name: &quot;Kyle&quot;, grade: 86 },
        { id: 73, name: &quot;Suzy&quot;, grade: 87 },
        { id: 112, name: &quot;Frank&quot;, grade: 75 },
        { id: 6, name: &quot;Sarah&quot;, grade: 91 }
    ];

    var publicAPI = {
        getName
    };

    return publicAPI;

    // ************************

    function getName(studentID) {
        var student = records.find(
            student =&gt; student.id == studentID
        );
        return student.name;
    }
}

var fullTime = defineStudent();
fullTime.getName(73);            // Suzy</code></pre><p id="cab6a646-04df-41f3-8094-6e303340e61c" class="">Rather than specifying <code>defineStudent()</code> as an IIFE, we just define it as a normal standalone function, which is commonly referred to in this context as a &quot;module factory&quot; function.</p><p id="18a7f7d7-54b5-4d37-ac7e-af1ee0a6df7a" class="">We then call the module factory, producing an instance of the module that we label <code>fullTime</code>. This module instance implies a new instance of the inner scope, and thus a new closure that <code>getName(..)</code> holds over <code>records</code>. <code>fullTime.getName(..)</code> now invokes the method on that specific instance.</p><h3 id="f2283a96-ca34-47cb-b469-8e892fe6d71f" class=""><strong>Classic Module Definition</strong></h3><p id="7fba6de1-8ae9-4c51-8bed-ec17b472e8a3" class="">So to clarify what makes something a classic module:</p><ul id="e126b1e3-0d04-4e3f-8212-b398ab755c89" class="bulleted-list"><li style="list-style-type:disc">There must be an outer scope, typically from a module factory function running at least once.</li></ul><ul id="b8cec796-0711-48bd-8eba-4cc00ca61fe7" class="bulleted-list"><li style="list-style-type:disc">The module&#x27;s inner scope must have at least one piece of hidden information that represents state for the module.</li></ul><ul id="1c281535-a477-406b-ad0f-b35481010d6d" class="bulleted-list"><li style="list-style-type:disc">The module must return on its public API a reference to at least one function that has closure over the hidden module state (so that this state is actually preserved).</li></ul><p id="48e17ad3-e5e7-409f-a552-523018dd7085" class="">You&#x27;ll likely run across other variations on this classic module approach, which we&#x27;ll look at in more detail in Appendix A.</p><p id="3be504c9-7a9c-4864-940a-fdb634950f5e" class="">
</p></div></article></body></html>